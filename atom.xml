<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crazy_cloud&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-30T10:05:42.935Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>crazy_cloud</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Chordal Graph</title>
    <link href="http://yoursite.com/2018/07/14/chordal-graph/"/>
    <id>http://yoursite.com/2018/07/14/chordal-graph/</id>
    <published>2018-07-14T00:25:38.000Z</published>
    <updated>2018-07-30T10:05:42.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>没想到自己退役之前居然点开了弦图的知识树……<br><del>我肯定不会告诉你是因为做 CC 的 JERRYTOM 才学这个东西的。</del><br>也就学到最大团为止了，后面的最大独立集什么好像也不难但是懒得写了……<br>(2018.07.14)<br>结果中途咕咕咕，凉完了 NOI，颓完了 CodeM Final，明天就要开学的我才强迫自己把坑填完。<br>(2018.07.30)<br><a id="more"></a></p><hr><h1 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h1><p>$G$ 一副无向图。<br>$G[S]$：$S$ 点集的诱导子图。<br>$\delta(S)$：$S$ 点集的邻集。</p><hr><h1 id="弦图的基本性质"><a href="#弦图的基本性质" class="headerlink" title="弦图的基本性质"></a>弦图的基本性质</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="弦"><a href="#弦" class="headerlink" title="弦"></a>弦</h3><p>环中连接两个非环上相邻点的边。</p><h3 id="弦图"><a href="#弦图" class="headerlink" title="弦图"></a>弦图</h3><p>任意长度大于 $3$ 的环都有至少一条弦的无向图。</p><h4 id="一个很显然的性质"><a href="#一个很显然的性质" class="headerlink" title="一个很显然的性质"></a>一个很显然的性质</h4><p>弦图的任意一个诱导子图一定是弦图。</p><h3 id="xy-点割"><a href="#xy-点割" class="headerlink" title="$xy$ - 点割"></a>$xy$ - 点割</h3><p>对于一对非相邻节点 $x$ 和 $y$，如果删掉点集 $S$ 能使得 $x$ 与 $y$ 在 $G-S$ 中不连通，那么 $S$ 是一个 $xy$ - 点割。</p><h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理 $1$"></a>定理 $1$</h3><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>$G$ 是弦图当且仅当对于所有的极小 $xy$ - 点割 $S$，$G[S]$ 都是一个团。 </p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>先证明必要性，假设 $G$ 是一个弦图，且其存在一个极小 $xy$ - 点割 $S$，$G[S]$ 并不是一个团。<br>考虑 $S$ 上两个非相邻节点 $u$ 和 $v$，由于 $S$ 是极小的 $xy$ - 点割，因此 $u$ 和 $v$ 一定都同时连接了至少一个 $x$ 集合的点和一个 $y$ 集合的点。<br>容易发现此时至少存在一个同时包含 $u$ 和 $v$ 的大小至少为 $4$ 的无弦环，矛盾。<br>再证明充分性，假设 $G$ 满足所有的极小 $xy$ - 点割 $S$ 的诱导子图都是一个团，但是 $G$ 不是弦图，也就是说 $G$ 至少存在一个大小为 $4$ 的无弦环。<br>考虑这个无弦环上两个非相邻节点 $u$ 和 $v$，它们的极小 $xy$ - 点割 $S$ 的诱导子图是一个团，显然要使这两个点不连通，$S$ 在它们环上两个方向的简单路径上都至少得有 $1$ 个点。由于 $S$ 是一个团，这两个点有连边，和环无弦矛盾。</p><h3 id="定理-2"><a href="#定理-2" class="headerlink" title="定理 $2$"></a>定理 $2$</h3><h4 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h4><p>令 $G$ 是一个非团弦图。假定 $S$ 是一个 $xy$ - 点割且 $G[S]$ 是一个团，令 $G_1,…,G_k$ 表示 $G-S$ 中的连通块。那么对于每一个连通块 $G_i$ 我们都可以选择出一个点 $x\in G_i$ 使得 $G[\delta(x)]$ 是一个团。</p><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>考虑对 $|G|$ 使用数学归纳法，首先 $|G|=3$ 的时候显然成立。<br>令 $V_1,…,V_k$ 表示 $G_1,…,G_k$ 中的点集。由弦图的性质，$G[V_i\bigcup S]$ 都是弦图。<br>由于 $S$ 是一个点割，也就是说对于所有 $v_i\in V_i$，$\delta(v_i) \subseteq V_i\bigcup S$。因此在 $G[V_i\bigcup S]$ 中，$G[\delta(v_i)]$ 如果是一个团，那么在 $G$ 中 $G[\delta(v_i)]$ 也是一个团。<br>如果 $G[V_i\bigcup S]$ 本身是一个团，那对于所有 $v_i\in V_i$，$G[\delta(v_i)]$ 都是一个团。<br>如果 $G[V_i\bigcup S]$ 本身不是一个团，那么考虑 $G[V_i\bigcup S]$ 中的一对非相邻节点 $u,v$，由定理 $1$，它们的极小 $xy$ - 点割 $S_i$ 是一个团，根据归纳，一定可以找到两个点 $a,b\in (V_i\bigcup S)\S_i$ ，使得在 $G[V_i\bigcup S]$ 中，$G[\delta(a)]$ 和 $G[\delta(b)]$ 都是团。<br>由于 $a,b$ 在点割 $S_i$ 的不同连通块，因此其中至少存在一个是属于 $V_i$ 的，假设其为 $a$，那么 $a$ 就是我们要找的 $v_i$。</p><hr><h1 id="弦图的完美消除序列"><a href="#弦图的完美消除序列" class="headerlink" title="弦图的完美消除序列"></a>弦图的完美消除序列</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><h3 id="单纯点"><a href="#单纯点" class="headerlink" title="单纯点"></a>单纯点</h3><p>一个点是单纯点当且仅当 $G[\delta(v)]$（或者 $G[{v}+\delta(v)]$）的诱导子图是一个团。</p><h3 id="完美消除序列"><a href="#完美消除序列" class="headerlink" title="完美消除序列"></a>完美消除序列</h3><p>完美消除序列是一个序列 ${v_1,v_2,…,v_n}$，图中每个点恰好出现一次，满足 $v_i$ 在 ${v_{i+1},v_{i+2},…,v_n}$ 的诱导子图中是单纯点。</p><h2 id="弦图完美消除序列的性质"><a href="#弦图完美消除序列的性质" class="headerlink" title="弦图完美消除序列的性质"></a>弦图完美消除序列的性质</h2><h3 id="引理-3"><a href="#引理-3" class="headerlink" title="引理 $3$"></a>引理 $3$</h3><h4 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h4><p>弦图 $G$ 至少存在一个单纯点。</p><h4 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h4><p>如果 $G$ 本身就是团，那么其每一个节点都是单纯点。<br>否则，考虑两个非相邻节点 $u$ 和 $v$，根据定理 $1$ 其极小 $xy$ - 点割 $S$ 的诱导子图一定是一个团，根据定理 $2$ 一定存在单纯点。</p><h3 id="定理-4"><a href="#定理-4" class="headerlink" title="定理 $4$"></a>定理 $4$</h3><h4 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h4><p>一个图是弦图当且仅当它有一个完美消除序列。</p><h4 id="证明-3"><a href="#证明-3" class="headerlink" title="证明"></a>证明</h4><p>先证明必要性，每次选出一个单纯点然后删掉它，诱导子图也是弦图，因此依然有单纯点。这样可以构造出弦图的完美消除序列。<br>再证明充分性，假设一个图不是弦图且存在完美消除序列，也就是说它存在一个长度大于 $3$ 的无弦环。那么假设这个环最早出现在消除序列中的点是 $v$，取其相邻节点 $v_1,v_2$，根据消除序列的定义 $(v_1,v_2)\in E$，和环无弦矛盾。</p><h2 id="最大势算法（Maximum-Cardinality-Search-MCS）"><a href="#最大势算法（Maximum-Cardinality-Search-MCS）" class="headerlink" title="最大势算法（Maximum Cardinality Search, MCS）"></a>最大势算法（Maximum Cardinality Search, MCS）</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>每个点有一个初始势能 $card(x)=0$。<br>从 $n$ 到 $1$ 确定完美消除序列的每一个元素，每次选择 $card(x)$ 最大的将其填入，并将其邻集中没有被选择的 $card$ 增加 $1$。<br>实现可以直接开 $n$ 个队列记录每种势能有哪些点，记录 $best$ 表示当前最大势能。节点势能增加移动至另一个队列的时候不需要删除原本的。<br>简单势能分析一下，复杂度是 $O(n+m)$ 的。</p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><h4 id="alpha-x"><a href="#alpha-x" class="headerlink" title="$\alpha(x)$"></a>$\alpha(x)$</h4><p>$x$ 在（通过 MCS 得到的）完美消除序列中的排名。</p><h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><h4 id="引理-5"><a href="#引理-5" class="headerlink" title="引理 $5$"></a>引理 $5$</h4><h5 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h5><p>对于点对 $u,v$ 满足 $\alpha(u)&lt;\alpha(v)$，如果存在点 $x$ 使得 $(u,x)\in E,(v,x)\not\in E$ 且 $\alpha(x)&gt;\alpha(v)$。那么一定存在点 $y$ 使得 $(v,y)\in E,(v,x)\not\in E$ 且 $\alpha(y)&gt;\alpha(v)$。</p><h5 id="证明-4"><a href="#证明-4" class="headerlink" title="证明"></a>证明</h5><p>若不成立则有 $\alpha(u)&gt;\alpha(v)$，矛盾。</p><h4 id="引理-6"><a href="#引理-6" class="headerlink" title="引理 $6$"></a>引理 $6$</h4><h5 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h5><p>假定有 $\alpha(x)&lt;\alpha(u)&lt;\alpha(v)$，如果 $u$ 和 $v$ 没有边，$x$ 和 $v$ 都有连边。那么一定存在一条 $u$ 到 $v$ 的只经过 $\alpha$ 值大于 $\alpha(u)$ 的简单路径。</p><h5 id="证明-5"><a href="#证明-5" class="headerlink" title="证明"></a>证明</h5><p>考虑节点 $u$，由于 $u$ 和 $v$ 不相邻，且 $x$ 连接了 $v$，使用引理 $5$ 可以得到一定存在一个 $u’$ 满足 $(u,u’)\in E,(x,u’)\not\in E$ 且 $\alpha(u’)&gt;\alpha(u)$。<br>分类讨论，如果 $\alpha(u’)&lt;\alpha(v)$，我们继续对 $x,u’,v$ 进行递归论证；否则我们继续对 $u,v,u’$ 进行递归论证。<br>递归的条件是 $3$ 个点的 $\alpha$ 值依次递增，第 $2$ 个点和第 $3$ 个点没有边，第 $1$ 个点和第 $3$ 个点有边。<br>只有第二个条件可能会不满足，这也意味着证明结束：此时就得到了一条只经过 $\alpha$ 值大于 $\alpha(u)$ 的点连接 $u$ 和 $v$ 的简单路径。注意到递归过程中三个点的 $\alpha$ 值至少有一个增大了，因此有限步内一定可以递归到边界。</p><h4 id="定理-7"><a href="#定理-7" class="headerlink" title="定理 $7$"></a>定理 $7$</h4><h5 id="内容-6"><a href="#内容-6" class="headerlink" title="内容"></a>内容</h5><p>在弦图上运行 MCS 算法可以得到弦图的一个完美消除序列。</p><h5 id="证明-6"><a href="#证明-6" class="headerlink" title="证明"></a>证明</h5><p>只需证明在弦图上运行 MCS 算法，选择点 $x$ 的时候，$x$ 在 $x$ 与已经被标记的点的诱导子图中是单纯点。<br>如果 $x$ 不是单纯点，那么 $x$ 一定和两个不相邻的已标记点 $u$ 和 $v$ 相连。<br>不妨令 $\alpha(x)&lt;\alpha(u)&lt;\alpha(v)$，由引理 $6$，存在一条只经过已标记点连接 $u$ 和 $v$ 的简单路径。<br>此时一定存在一个长度大于 $3$ 的无弦环，矛盾。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MCS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> best=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x) link[card[x]=<span class="number">0</span>].push(x),vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=n,p;j&gt;=<span class="number">1</span>;--j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (p=<span class="number">0</span>,++best;!p;)</span><br><span class="line">&#123;</span><br><span class="line">--best;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x;!link[best].empty();)</span><br><span class="line">&#123;</span><br><span class="line">x=link[best].front(),link[best].pop();</span><br><span class="line"><span class="keyword">if</span> (!vis[x])</span><br><span class="line">&#123;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=last[x],y;i;i=nxt[i])</span><br><span class="line"><span class="keyword">if</span> (!vis[y=tov[i]])</span><br><span class="line">link[++card[y]].push(y),best=max(best,card[y]);</span><br><span class="line">p=x;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">seq[rk[p]=j]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (;best;--best) <span class="keyword">for</span> (;!link[best].empty();link[best].pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="弦图的判定"><a href="#弦图的判定" class="headerlink" title="弦图的判定"></a>弦图的判定</h2><p>对给定的图 $G$ 运行 MCS 算法，判定的到的序列是否是一个完美消除序列。<br>朴素的方法是 $O(n^3)$ 的。<br>利用完美消除序列的性质，我们只需要倒过来枚举每一个元素 $x$，假定与其相连的且 $\alpha$ 值比其大的点按 $\alpha$ 排序依次是 $p_1,p_2,…,p_k$，那么只需要判定 $p_1$ 是否与其它点直接相连即可。时间复杂度 $O(n+m)$。</p><hr><h1 id="弦图的其它问题"><a href="#弦图的其它问题" class="headerlink" title="弦图的其它问题"></a>弦图的其它问题</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><h3 id="N-v"><a href="#N-v" class="headerlink" title="$N(v)$"></a>$N(v)$</h3><p>$N(v)=\{w|w\in\delta(v),\alpha(v)&lt;\alpha(w)\}$。</p><h2 id="最大团-极大团"><a href="#最大团-极大团" class="headerlink" title="最大团/极大团"></a>最大团/极大团</h2><h3 id="定理-8"><a href="#定理-8" class="headerlink" title="定理 $8$"></a>定理 $8$</h3><h4 id="内容-7"><a href="#内容-7" class="headerlink" title="内容"></a>内容</h4><p>弦图的极大团一定是 $G[v\bigcup N(v)]$ 的形式。</p><h4 id="证明-7"><a href="#证明-7" class="headerlink" title="证明"></a>证明</h4><p>首先 $G[v\bigcup N(v)]$ 一定是一个团。<br>假设点集 $V$ 的诱导子图是一个极大团。令 $v$ 是其中 $\alpha$ 最小的点，那么 $V \subseteq G[v\bigcup N(v)]$。又由于 $V$ 是极大团，那么 $V=G[v\bigcup N(v)]$。</p><h3 id="推论-9"><a href="#推论-9" class="headerlink" title="推论 $9$"></a>推论 $9$</h3><p>弦图的最多有 $n$ 个极大团。</p><h3 id="判定-G-v-bigcup-N-v-是否是一个极大团"><a href="#判定-G-v-bigcup-N-v-是否是一个极大团" class="headerlink" title="判定 $G[v\bigcup N(v)]$ 是否是一个极大团"></a>判定 $G[v\bigcup N(v)]$ 是否是一个极大团</h3><p>如果存在 $w$ 使得 $v\bigcup N(v)\subset w\bigcup N(w)$ 则 $G[v\bigcup N(v)]$ 并不是一个极大团。</p><p>令 $next(v)$ 表示 $N(v)$ 中 $\alpha$ 最小的节点。如果 $G[v\bigcup N(v)]$ 不是极大团，令 $w^{*}$ 是所有满足 $v\bigcup N(v)\subset w\bigcup N(w)$ 的 $\alpha$ 最大的 $w$。<br>那么一定有 $next(w^{*})=v$，否则 $next(w^{*})$ 是满足条件的 $\alpha$ 更大的 $w$（$next(w^{*})\in G[w\bigcup N(w)]$，因此 $v\bigcup N(v)$ 的每一个节点都和 $next(w^{*})$ 有连边）。</p><p>也就是说我们只需要判断 $next(w)=v$ 的点 $w$。<br>由于 $w\bigcup N(w)$ 是一个团，且 $v\in w\bigcup N(w)$，且 $next(w)=v$，因此 $(N(w)\backslash w)\subseteq N(v)$。<br>所以 $v\bigcup N(v)\subset w\bigcup N(w)$ 当且仅当 $|N(v)|+1\leq|N(w)|$。<br>按照本人的理解这里可以写作 $|N(v)|+1=|N(w)|$，但是大家写的好像都是 $\leq$，如果我理解有误欢迎读者指正。</p><h2 id="最小染色"><a href="#最小染色" class="headerlink" title="最小染色"></a>最小染色</h2><p>小坑待填。</p><h2 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h2><p>小坑待填。</p><h2 id="最小团覆盖"><a href="#最小团覆盖" class="headerlink" title="最小团覆盖"></a>最小团覆盖</h2><p>小坑待填。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;没想到自己退役之前居然点开了弦图的知识树……&lt;br&gt;&lt;del&gt;我肯定不会告诉你是因为做 CC 的 JERRYTOM 才学这个东西的。&lt;/del&gt;&lt;br&gt;也就学到最大团为止了，后面的最大独立集什么好像也不难但是懒得写了……&lt;br&gt;(2018.07.14)&lt;br&gt;结果中途咕咕咕，凉完了 NOI，颓完了 CodeM Final，明天就要开学的我才强迫自己把坑填完。&lt;br&gt;(2018.07.30)&lt;br&gt;
    
    </summary>
    
      <category term="学习小记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="弦图" scheme="http://yoursite.com/tags/%E5%BC%A6%E5%9B%BE/"/>
    
      <category term="归纳" scheme="http://yoursite.com/tags/%E5%BD%92%E7%BA%B3/"/>
    
  </entry>
  
  <entry>
    <title>hihoCoder Challenge 31 C - Good 01-Sequence</title>
    <link href="http://yoursite.com/2018/06/28/hihocoder-challenge31-c/"/>
    <id>http://yoursite.com/2018/06/28/hihocoder-challenge31-c/</id>
    <published>2018-06-28T13:39:15.000Z</published>
    <updated>2018-06-28T14:22:40.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>对 $01$ 串 $S$ 定义函数 $f(S)$，表示一个最小的整数 $k$，使得 $S$ 可以表示成 $k$ 个 $01$ 串的拼接（$S=t_1t_2…t_k$），且每一个 $01$ 串 $t_i$ 的逆序对数都是奇数。特殊地，如果不存在任何一种合法的划分方案，则定义 $f(S)=0$。<br>现在给定一个 $01$ 串 $S$，请求出其所有非空子序列的 $f$ 值之和。</p><p>$1\leq|S|\leq10^5$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>先考虑 $f(S)$ 的取值有哪些可能。<br>可以发现当 $k\geq3$ 的时候，任意三个连续的 $t_i$ 必须满足最前面的那一段 $1$ 的个数是奇数（否则前三段的逆序对数和后两段的逆序对数奇偶性会不同，段数并不是最优），第二段 $0$ 的个数一定是偶数（否则前两段的逆序对数就是奇数）。<br>因此，当 $k\geq4$ 时，$t_1t_2t_3$ 和 $t_2t_3t_4$ 都满足这样的关系，此时可以发现 $t_1t_2t_3$ 的逆序对数一定是奇数，段数不是最优。也就是说 $k$ 一定小于等于 $3$。<br>有了这个性质，我们可以考虑 dp 套 dp，令 $f_{i,j,k,s_1,s_2}$ 表示当前做到第 $i$ 位，选择了的所有数中 $1$ 个数的奇偶性是 $j$，总的逆序对数的奇偶性是 $k$，如果选到了第二段，第二段当前 $1$ 的个数奇偶性为 $0/1$，逆序对个数奇偶性为 $0/1$ 是否可行（一个$2^4$的二进制状态 $s_1$，第三段状态 $s_2$ 同理）的方案数，显然有了这些信息我们就足够分析一种子序列对答案的贡献。<br>转移和统计答案都很简单。<br>时间复杂度 $O(n\times 2^{16})$（若干常数就不分析了）。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span></span>&#123;x=x+y&gt;=P?x+y-P:x+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">1</span>&lt;&lt;L][<span class="number">1</span>&lt;&lt;L];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> tar=i&amp;<span class="number">1</span>,src=tar^<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(f[tar],<span class="number">0</span>,<span class="keyword">sizeof</span> f[tar]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> one=<span class="number">0</span>;one&lt;<span class="number">2</span>;++one)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> inv=<span class="number">0</span>;inv&lt;<span class="number">2</span>;++inv)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;<span class="number">1</span>&lt;&lt;L;++s)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s_=<span class="number">0</span>,tmp;s_&lt;<span class="number">1</span>&lt;&lt;L;++s_)</span><br><span class="line"><span class="keyword">if</span> (tmp=f[src][one][inv][s][s_])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//skip this digit</span></span><br><span class="line">add(f[tar][one][inv][s][s_],tmp);</span><br><span class="line"><span class="comment">//select this digit</span></span><br><span class="line"><span class="keyword">int</span> one_=one^(str[i]-<span class="string">'0'</span>),inv_=inv^(str[i]==<span class="string">'0'</span>)*one;</span><br><span class="line"><span class="comment">//start the second block</span></span><br><span class="line"><span class="keyword">int</span> ds=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (inv&amp;<span class="number">1</span>) ds=<span class="number">1</span>&lt;&lt;str[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//continue the second block</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,one__,inv__;j&lt;L;++j)</span><br><span class="line"><span class="keyword">if</span> (s&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">one__=j&amp;<span class="number">1</span>,inv__=j&gt;&gt;<span class="number">1</span>;</span><br><span class="line">one__=one__^(str[i]-<span class="string">'0'</span>);</span><br><span class="line">inv__=inv__^(str[i]==<span class="string">'0'</span>)*one__;</span><br><span class="line">ds|=<span class="number">1</span>&lt;&lt;(inv__&lt;&lt;<span class="number">1</span>|one__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//start the third block</span></span><br><span class="line"><span class="keyword">int</span> ds_=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;L;++j) <span class="keyword">if</span> (s&gt;&gt;j&amp;<span class="number">1</span>) ds_|=<span class="number">1</span>&lt;&lt;str[i]-<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//continue the third block</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,one__,inv__;j&lt;L;++j)</span><br><span class="line"><span class="keyword">if</span> (s_&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">one__=j&amp;<span class="number">1</span>,inv__=j&gt;&gt;<span class="number">1</span>;</span><br><span class="line">one__=one__^(str[i]-<span class="string">'0'</span>);</span><br><span class="line">inv__=inv__^(str[i]==<span class="string">'0'</span>)*one__;</span><br><span class="line">ds_|=<span class="number">1</span>&lt;&lt;(inv__&lt;&lt;<span class="number">1</span>|one__);</span><br><span class="line">&#125;</span><br><span class="line">add(f[tar][one_][inv_][ds][ds_],tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> one=<span class="number">0</span>;one&lt;<span class="number">2</span>;++one)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> inv=<span class="number">0</span>;inv&lt;<span class="number">2</span>;++inv)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;<span class="number">1</span>&lt;&lt;L;++s)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s_=<span class="number">0</span>,tmp,k;s_&lt;<span class="number">1</span>&lt;&lt;L;++s_)</span><br><span class="line"><span class="keyword">if</span> (tmp=f[n&amp;<span class="number">1</span>^<span class="number">1</span>][one][inv][s][s_])</span><br><span class="line">&#123;</span><br><span class="line">k=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;L;++j) <span class="keyword">if</span> (s_&gt;&gt;j&amp;<span class="number">1</span>)&#123;k=<span class="number">3</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;L;++j) <span class="keyword">if</span> (s&gt;&gt;j&amp;<span class="number">1</span>)&#123;k=<span class="number">2</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span> (inv&amp;<span class="number">1</span>) k=<span class="number">1</span>;</span><br><span class="line">k*=k!=<span class="number">4</span>;</span><br><span class="line">add(ans,<span class="number">1l</span>l*tmp*k%P);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"seq.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"seq.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str),n=<span class="built_in">strlen</span>(str);</span><br><span class="line">dp(),calc(),<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;对 $01$ 串 $S$ 定义函数 $f(S)$，表示一个最小的整数 $k$，使得 $S$ 可以表示成 $k$ 个 $01$ 串的拼接（$S=t_1t_2…t_k$），且每一个 $01$ 串 $t_i$ 的逆序对数都是奇数。特殊地，如果不存在任何一种合法的划分方案，则定义 $f(S)=0$。&lt;br&gt;现在给定一个 $01$ 串 $S$，请求出其所有非空子序列的 $f$ 值之和。&lt;/p&gt;
&lt;p&gt;$1\leq|S|\leq10^5$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="bitmasks" scheme="http://yoursite.com/tags/bitmasks/"/>
    
      <category term="计数类问题" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="状压动态规划" scheme="http://yoursite.com/tags/%E7%8A%B6%E5%8E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="hihoCoder" scheme="http://yoursite.com/tags/hihoCoder/"/>
    
      <category term="逆序对" scheme="http://yoursite.com/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
      <category term="dp 套 dp" scheme="http://yoursite.com/tags/dp-%E5%A5%97-dp/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 995F Cowmpany Cowmpensation</title>
    <link href="http://yoursite.com/2018/06/27/codeforces-995f/"/>
    <id>http://yoursite.com/2018/06/27/codeforces-995f/</id>
    <published>2018-06-27T14:02:44.000Z</published>
    <updated>2018-06-27T14:21:33.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一棵 $1$ 为根的树，你要给每一个点分配一个 $1$ 到 $D$ 之间的权值，使得每一个点的权值都小于等于其父亲节点的权值。<br>求出方案数，对 $10^9+7$ 取模。</p><p>$1\leq n\leq3\times10^3,1\leq D\leq10^9$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>考虑最简单的 dp，令 $f_{x,i}$ 表示做到第 $x$ 个点为根的子树中，$x$ 填 $i$ 时的方案总数。<br>使用前缀和优化一下就可以做到 $O(nD)$。</p><p>经过观察，可以发现其实 $f_{x,i}$ 是一个关于 $i$ 的最高次数为 $size(x)-1$ 的多项式。<br>这个用归纳法很好证明：在叶子节点处 $f_{x,i}=1$ 显然成立；对于非叶子节点，假设其所有儿子节点都满足，定义 $g_{x,i}$ 是 $f_{x,i}$ 的前缀和，那么其所有儿子 $y$ 的 $g_{y,i}$ 都是最高次数为 $size(y)$ 的多项式，dp 的转移是对应位置相乘，因此点 $f_{x,i}$ 就是一个最高次数为 $size(x)-1$ 的多项式。</p><p>有了这个结论，我们 dp 的时候只需要保留数组的前 $0…n$ 项，然后直接插值插出 $g_{1,D}$ 就好了。<br>时间复杂度 $O(n^2)$。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3005</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span></span>&#123;x=x+y&gt;=P?x+y-P:x+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%P) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) ret=<span class="number">1l</span>l*ret*x%P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sig</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;<span class="number">1</span>?P<span class="number">-1</span>:<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fact[N],invf[N],prex[N],sufx[N],last[N],fa[N],tov[N],nxt[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> n,D,tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fact[i]=<span class="number">1l</span>l*fact[i<span class="number">-1</span>]*i%P;</span><br><span class="line">invf[n]=quick_power(fact[n],P<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) invf[i<span class="number">-1</span>]=<span class="number">1l</span>l*invf[i]*i%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[x][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=last[x],y;i;i=nxt[i])</span><br><span class="line"><span class="keyword">if</span> ((y=tov[i])!=fa)</span><br><span class="line">&#123;</span><br><span class="line">dp(y,x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) f[x][j]=<span class="number">1l</span>l*f[x][j]*f[y][j]%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) add(f[x][i],f[x][i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">prex[<span class="number">0</span>]=x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) prex[i]=<span class="number">1l</span>l*prex[i<span class="number">-1</span>]*(x-i+P)%P;</span><br><span class="line">sufx[n]=(x-n+P)%P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) sufx[i]=<span class="number">1l</span>l*sufx[i+<span class="number">1</span>]*(x-i+P)%P;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) add(ret,<span class="number">1l</span>l*(i?prex[i<span class="number">-1</span>]:<span class="number">1</span>)*(i&lt;n?sufx[i+<span class="number">1</span>]:<span class="number">1</span>)%P*invf[i]%P*invf[n-i]%P*sig(n-i)%P*f[i]%P);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"cow.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"cow.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;D),pre();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">2</span>;x&lt;=n;++x) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;fa[x]),insert(fa[x],x);</span><br><span class="line">dp(<span class="number">1</span>),<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,F(f[<span class="number">1</span>],D));</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一棵 $1$ 为根的树，你要给每一个点分配一个 $1$ 到 $D$ 之间的权值，使得每一个点的权值都小于等于其父亲节点的权值。&lt;br&gt;求出方案数，对 $10^9+7$ 取模。&lt;/p&gt;
&lt;p&gt;$1\leq n\leq3\times10^3,1\leq D\leq10^9$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="树形动态规划" scheme="http://yoursite.com/tags/%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="归纳" scheme="http://yoursite.com/tags/%E5%BD%92%E7%BA%B3/"/>
    
      <category term="多项式" scheme="http://yoursite.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="Codeforces" scheme="http://yoursite.com/tags/Codeforces/"/>
    
      <category term="拉格朗日插值" scheme="http://yoursite.com/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>HackerEarth June Circuit &#39;18 - Choose items</title>
    <link href="http://yoursite.com/2018/06/26/hackerearth-june-circuits-18-choose-items/"/>
    <id>http://yoursite.com/2018/06/26/hackerearth-june-circuits-18-choose-items/</id>
    <published>2018-06-26T14:07:30.000Z</published>
    <updated>2018-06-26T14:38:22.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>并不是一道怎么棒棒的题，但是鏖战了一定的时间，还是 mark 一下吧……</p><hr><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定长度为 $n$ 的序列 ${c_i}$。<br>有 $q$ 次询问，每次询问给定 $l,r,k$。你需要回答$$[x^k] \prod_{i=l}^r(1+c_ix)$$答案对 $998244353$ 取模。强制在线。</p><p>$1\leq n,q\leq 2^{14}$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>有一个很 naive 的想法就是直接存下每一个位置的前缀积的各项点值，这个可以 $O(n^2)$ 暴力算。然后每次询问两端相除再 IDFT 回来就好了，特判一下 $0$ 的情况。<br>这样做会 MLE。考虑分块，设一个阈值 $T$，我们每隔 $T$ 个位置存一下前缀积点值。询问时对于整块直接 IDFT。对于散块，考虑到 $T$ 可以设置得很小（只要在空间允许范围内，并不会影响时间复杂度），而算法的瓶颈主要在于 IDFT，因此我们可以直接用 $O(T^2)$ 的暴力来完成散块多项式的计算。<br>这样可以做到时间复杂度 $O(qn\log n)$。<br>可是这样还是通过不了这一题。注意到整块两两的搭配只有 $O\left((\frac nT)^2\right)$ 种，我们直接预处理任意两个块之间的所有双项式的乘积。然后对于整块，我们考虑使用分治 FFT 或者线段树加 FFT 来得到多项式。<br>这样做的复杂度是 $O\left((\frac nT)^2n\log n+qT\log^2 T\right)$。<br>考虑阈值均衡，将 $q$ 看成与 $n$ 同阶，粗略地取 $T=\left(\frac{n^2}{\log n}\right)^{\frac 13}$ 即可通过此题。<br>总用时跑了 80 多秒……并不知道只跑了 9s 的 mcfx 神仙写的是什么……</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line"><span class="keyword">for</span> (;x;x/=<span class="number">10</span>) buf[++buf[<span class="number">0</span>]]=x%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (!buf[<span class="number">0</span>]) buf[++buf[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;buf[<span class="number">0</span>];<span class="built_in">putchar</span>(<span class="string">'0'</span>+buf[buf[<span class="number">0</span>]--]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L=<span class="number">14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1</span>&lt;&lt;L;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_BLOCK_SIZE=<span class="number">275</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_BLOCK_CNT=<span class="number">65</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span></span>&#123;x=x+y&gt;=P?x+y-P:x+y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span></span>&#123;x=x&lt;y?x-y+P:x-y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x+y&gt;=P?x+y-P:x+y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x-y+P:x-y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%P) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) ret=<span class="number">1l</span>l*ret*x%P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],t[N],trs[N];</span><br><span class="line"><span class="keyword">int</span> g[L][<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> omega[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> len,len_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAX_BLOCK_CNT*MAX_BLOCK_CNT&gt;&gt;<span class="number">1</span>][N];</span><br><span class="line"><span class="keyword">int</span> st[MAX_BLOCK_CNT],en[MAX_BLOCK_CNT];</span><br><span class="line"><span class="keyword">int</span> bel[N],c[N],coef[N];</span><br><span class="line"><span class="keyword">int</span> n,q,siz,cnt,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT_pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> g=quick_power(G,(P<span class="number">-1</span>)/N);omega[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i) omega[i]=<span class="number">1l</span>l*omega[i<span class="number">-1</span>]*g%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deg_pre</span><span class="params">(<span class="keyword">int</span> deg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (len=<span class="number">1</span>;len&lt;deg;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,ret;i&lt;len;++i)</span><br><span class="line">&#123;</span><br><span class="line">ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=i,j=<span class="number">1</span>;j&lt;len;j&lt;&lt;=<span class="number">1</span>,x&gt;&gt;=<span class="number">1</span>) ret=(ret&lt;&lt;<span class="number">1</span>)|(x&amp;<span class="number">1</span>);</span><br><span class="line">trs[i]=ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFT</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) t[trs[i]]=a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> l=<span class="number">2</span>;l&lt;=len;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> h=l&gt;&gt;<span class="number">1</span>,j=<span class="number">0</span>,wn=omega[sig&gt;<span class="number">0</span>?N/l:N-N/l];j&lt;len;j+=l)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>,w=<span class="number">1</span>;i&lt;h;++i,w=<span class="number">1l</span>l*w*wn%P)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> u=t[i+j],v=<span class="number">1l</span>l*t[i+j+h]*w%P;</span><br><span class="line">t[i+j]=add(u,v),t[i+j+h]=sub(u,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=t[i];</span><br><span class="line"><span class="keyword">if</span> (sig&lt;<span class="number">0</span>) <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>,inv=quick_power(len,P<span class="number">-2</span>);i&lt;len;++i) a[i]=<span class="number">1l</span>l*a[i]*inv%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b,<span class="keyword">int</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DFT(a,<span class="number">1</span>),DFT(b,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) c[i]=<span class="number">1l</span>l*a[i]*b[i]%P;</span><br><span class="line">DFT(c,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz=max((<span class="keyword">int</span>)trunc(<span class="built_in">pow</span>(<span class="number">1.</span>*n*n/(<span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">2</span>)),<span class="number">1.</span>/<span class="number">3.</span>)),<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> src=<span class="number">0</span>,tar;src&lt;n;src=tar,++cnt)</span><br><span class="line">&#123;</span><br><span class="line">tar=min(src+siz,n),st[cnt]=src,en[cnt]=tar<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=src;i&lt;tar;++i) bel[i]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> en=cnt,st=cnt-l+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1l</span>l*(st+en)*(en-st+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)+r-l+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTT_pre(),deg_pre(n),block();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,id;i&lt;cnt;++i)</span><br><span class="line">&#123;</span><br><span class="line">id=getid(i,i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;++j) f[id][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=st[i];j&lt;=en[i];++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;len;++k)</span><br><span class="line">f[id][k]=<span class="number">1l</span>l*f[id][k]*(<span class="number">1l</span>l*c[j]*omega[N/len*k]%P+<span class="number">1</span>)%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;cnt;++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>,id=getid(i,j),id_=getid(i,j<span class="number">-1</span>),id__=getid(j,j);k&lt;len;++k)</span><br><span class="line">f[id][k]=<span class="number">1l</span>l*f[id_][k]*f[id__][k]%P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;cnt;++j) DFT(f[getid(i,j)],<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&gt;r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (l==r)&#123;g[d][<span class="number">0</span>]=<span class="number">1</span>,g[d][<span class="number">1</span>]=coef[l];<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,deg=r-l+<span class="number">2</span>,deg0=mid-l+<span class="number">2</span>,deg1=r-mid+<span class="number">1</span>;</span><br><span class="line">solve(l,mid,d+<span class="number">1</span>),copy(g[d+<span class="number">1</span>],g[d+<span class="number">1</span>]+deg0,g[d]),solve(mid+<span class="number">1</span>,r,d+<span class="number">1</span>);</span><br><span class="line">deg_pre(deg),fill(g[d]+deg0,g[d]+len,<span class="number">0</span>),fill(g[d+<span class="number">1</span>]+deg1,g[d+<span class="number">1</span>]+len,<span class="number">0</span>);</span><br><span class="line">FFT(g[d],g[d+<span class="number">1</span>],g[d]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">0</span>,idx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;l!=st[bel[l]]&amp;&amp;l&lt;=r;++l) coef[idx++]=c[l];</span><br><span class="line"><span class="keyword">for</span> (;r!=en[bel[r]]&amp;&amp;l&lt;=r;--r) coef[idx++]=c[r];</span><br><span class="line"><span class="keyword">if</span> (idx&gt;<span class="number">30</span>) solve(<span class="number">0</span>,idx<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=idx;++i) g[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">g[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=idx;j&gt;=<span class="number">1</span>;--j)</span><br><span class="line">Add(g[<span class="number">0</span>][j],<span class="number">1l</span>l*g[<span class="number">0</span>][j<span class="number">-1</span>]*coef[i]%P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> id=getid(bel[l],bel[r]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=idx&amp;&amp;i&lt;k;++i) Add(ret,<span class="number">1l</span>l*g[<span class="number">0</span>][i]*(k-i==len_?sub(f[id][<span class="number">0</span>],<span class="number">1</span>):f[id][k-i])%P);</span><br><span class="line"><span class="keyword">if</span> (k&lt;=idx) Add(ret,g[<span class="number">0</span>][k]);</span><br><span class="line">&#125;<span class="keyword">else</span> ret=g[<span class="number">0</span>][k];</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"choose.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"choose.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">n=read(),q=read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) c[i]=read();</span><br><span class="line">pre(),len_=len,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,l,r,k;i&lt;=q;++i)</span><br><span class="line">&#123;</span><br><span class="line">l=(read()+ans)%n,r=(read()+ans)%n,k=read();</span><br><span class="line">ans=calc(l,r,k),write(ans),<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;并不是一道怎么棒棒的题，但是鏖战了一定的时间，还是 mark 一下吧……&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定长度为 $n$ 的序列 ${c_i}$。&lt;br&gt;有 $q$ 次询问，每次询问给定 $l,r,k$。你需要回答$$[x^k] \prod_{i=l}^r(1+c_ix)$$答案对 $998244353$ 取模。强制在线。&lt;/p&gt;
&lt;p&gt;$1\leq n,q\leq 2^{14}$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="FFT/NTT/FWT" scheme="http://yoursite.com/tags/FFT-NTT-FWT/"/>
    
      <category term="多项式" scheme="http://yoursite.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="预处理" scheme="http://yoursite.com/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
      <category term="阈值均衡" scheme="http://yoursite.com/tags/%E9%98%88%E5%80%BC%E5%9D%87%E8%A1%A1/"/>
    
      <category term="分块" scheme="http://yoursite.com/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="HackerEarth" scheme="http://yoursite.com/tags/HackerEarth/"/>
    
  </entry>
  
  <entry>
    <title>hihoCoder Challenge 33 C - 加减</title>
    <link href="http://yoursite.com/2018/06/13/hihocoder-challenge33-c/"/>
    <id>http://yoursite.com/2018/06/13/hihocoder-challenge33-c/</id>
    <published>2018-06-13T12:04:26.000Z</published>
    <updated>2018-06-13T12:33:39.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>定义对正整数 $x$ 的一次变换为：有 $1/2$ 的概率变成 $x+\operatorname{lowbit}(x)$，$1/2$ 的概率变成 $x-\operatorname{lowbit}(x)$。<br>定义 $f(x)$ 表示正整数 $x$ 变换为 $0$ 的期望步数。<br>给定 $L,R$，求 $\sum_{x=L}^Rf(x)$。</p><p>$0\leq L\leq R\lt 2^{31}$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>考虑计算 $f$ 的前缀和。</p><p>乍一看加加减减的，似乎一个数操作若干次会变回来，其实不然。<br>仔细分析性质，我们可以发现：<br>$\bullet$ 不管是 $+\operatorname{lowbit}$ 还是 $-\operatorname{lowbit}$，过程虽然是曲折的，数值可能会变大变小，但是后缀连续零是前进的，每次操作后严格递增的。（被学业水平测试带跑的哲学语气）<br>$\bullet$ 一个位置最多只会被进位一次。</p><p>因此我们可以考虑一个从低位往高位的数位 $dp$，令 $f_{i,j,k}$ 表示 $0…i-1$ 位上都已经变成了 $0$，当前这一位是（否）有来自 $i-1$ 的进位，以及 $0…i-1$ 组成的二进制数是（否）小于上界这些位置对应的二进制数情况下的期望，为了转移，我们还要类似地记录这种情况的概率。<br>转移很简单，直接考虑这一位填什么，简单讨论就好了。</p><p>现在还有一个问题就是我们可能在填完所有位之后，依然有进位。注意到这个时候只有这一个最高位的 $1$，利用简单的期望知识就可以得到它能在期望 $2$ 步内被删除，我们统计这种情况出现的概率乘上 $2$ 就能处理了。<br>时间复杂度 $O\left(\log(R)\right)$。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> itwo=P+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L=<span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span></span>&#123;x=x+y&gt;=P?x+y-P:x+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[L+<span class="number">5</span>][<span class="number">2</span>][<span class="number">2</span>],g[L+<span class="number">5</span>][<span class="number">2</span>][<span class="number">2</span>];<span class="comment">//expectation probability</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f),<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">g[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,d;i&lt;L;++i)</span><br><span class="line">&#123;</span><br><span class="line">d=n&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>,<span class="built_in">exp</span>,pro;k&lt;<span class="number">2</span>;++k)</span><br><span class="line"><span class="keyword">if</span> (f[i][j][k]||g[i][j][k])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exp</span>=f[i][j][k],pro=g[i][j][k];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">2</span>;++x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> k_=x&lt;d||(k&amp;&amp;x==d);</span><br><span class="line"><span class="keyword">if</span> (j^x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> dexp=<span class="number">1l</span>l*itwo*(pro+<span class="built_in">exp</span>)%P,dpro=<span class="number">1l</span>l*itwo*pro%P;</span><br><span class="line"><span class="comment">//+lowbit</span></span><br><span class="line">add(f[i+<span class="number">1</span>][<span class="number">1</span>][k_],dexp),add(g[i+<span class="number">1</span>][<span class="number">1</span>][k_],dpro);</span><br><span class="line"><span class="comment">//-lowbit</span></span><br><span class="line">add(f[i+<span class="number">1</span>][<span class="number">0</span>][k_],dexp),add(g[i+<span class="number">1</span>][<span class="number">0</span>][k_],dpro);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> add(f[i+<span class="number">1</span>][j&amp;&amp;x][k_],<span class="built_in">exp</span>),add(g[i+<span class="number">1</span>][j&amp;&amp;x][k_],pro);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">2l</span>l*g[L][<span class="number">1</span>][<span class="number">1</span>]+f[L][<span class="number">0</span>][<span class="number">1</span>]+f[L][<span class="number">1</span>][<span class="number">1</span>])%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"lowbit.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"lowbit.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r),<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(dp(r)-dp(l<span class="number">-1</span>)+P)%P);</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;定义对正整数 $x$ 的一次变换为：有 $1/2$ 的概率变成 $x+\operatorname{lowbit}(x)$，$1/2$ 的概率变成 $x-\operatorname{lowbit}(x)$。&lt;br&gt;定义 $f(x)$ 表示正整数 $x$ 变换为 $0$ 的期望步数。&lt;br&gt;给定 $L,R$，求 $\sum_{x=L}^Rf(x)$。&lt;/p&gt;
&lt;p&gt;$0\leq L\leq R\lt 2^{31}$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="计数类问题" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="概率与期望" scheme="http://yoursite.com/tags/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="hihoCoder" scheme="http://yoursite.com/tags/hihoCoder/"/>
    
      <category term="数位动态规划" scheme="http://yoursite.com/tags/%E6%95%B0%E4%BD%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2017 TCO Round 3A Division I Hard, HiddenRabbits</title>
    <link href="http://yoursite.com/2018/05/24/topcoder-tco17-3a-div1-hard/"/>
    <id>http://yoursite.com/2018/05/24/topcoder-tco17-3a-div1-hard/</id>
    <published>2018-05-24T14:02:59.000Z</published>
    <updated>2018-05-24T14:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一棵 $n$ 个节点的无根树。<br>你需要构造一个函数 $f:[m]\rightarrow T$ 满足若干个形如 $(r_i,a_i,b_i,x_i)$ 的限制。<br>一个限制表示当 $r_i$ 为根的时候，$\operatorname{LCA}\left(f(a_i),f(b_i)\right)=x_i$。</p><p>$2\leq n\leq251,2\leq m\leq 250$<br>限制的个数 $\leq 250$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>定义 $F_{x,y,z}$ 表示 $f(z)$ 是否在有向边 $(x,y)$ 的子树内。显然 $F_{x,y,z}$ 和 $F_{y,x,z}$ 共同构成了一个布尔变量。<br>根据树的形态我们可以得到 $F_{y,z,p}\rightarrow F_{x,y,p}$。<br>至于限制的要求，首先 $f(a_i)$ 和 $f(b_i)$ 得都在 $x_i$ 子树内，即 $F_{fa_{x_i},x_i,a_i}=1$ 以及 $F_{fa_{x_i},x_i,b_i}=1$。<br>其次，它们得属于不同子树，即 $\forall (x_i,y)\in E,y\neq fa_{x_i},F_{x_i,y,a_i} \land F_{x_i,y,b_i}=0$。<br>跑一遍 2-SAT 即可出解。<br>时间复杂度 $O(mn^2)$ 吧大概。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">251</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">250</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q=<span class="number">250</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V=M*(N<span class="number">-1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> E=<span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(a,b) make_pair(a,b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bel[V],DFN[V],low[V],last[V],deg[V],rev[V],nd[V];</span><br><span class="line"><span class="keyword">bool</span> chosen[V],vis[V],exist[V];</span><br><span class="line"><span class="keyword">int</span> fa[N][N],fe[N][N];</span><br><span class="line"><span class="built_in">vector</span>&lt;data&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> edge_tmp[E][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[E],tov[E];</span><br><span class="line"><span class="keyword">int</span> n,v,tot,idx,scc_cnt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> eid)</span></span>&#123;<span class="keyword">return</span> (x*(n<span class="number">-1</span>)&lt;&lt;<span class="number">1</span>)+eid;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">bool</span> rec=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;</span><br><span class="line"><span class="keyword">if</span> (rec) edge_tmp[tot][<span class="number">0</span>]=x,edge_tmp[tot][<span class="number">1</span>]=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> *fa,<span class="keyword">int</span> *fe)</span></span>&#123;<span class="keyword">for</span> (data e:edge[x]) <span class="keyword">if</span> (e.ft!=fa[x]) fa[e.ft]=x,fe[e.ft]=e.sd,dfs(e.ft,fa,fe);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DFN[x]=low[x]=++idx,st.push(x),exist[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=last[x],y;i;i=nxt[i])</span><br><span class="line"><span class="keyword">if</span> (!DFN[y=tov[i]]) tarjan(y),low[x]=min(low[x],low[y]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (exist[y]) low[x]=min(low[x],DFN[y]);</span><br><span class="line"><span class="keyword">if</span> (DFN[x]==low[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">do</span>&#123;bel[y=st.top()]=scc_cnt,st.pop(),exist[y]=<span class="number">0</span>;&#125;<span class="keyword">while</span> (x!=y);</span><br><span class="line">nd[scc_cnt++]=x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floodfill</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line">vis[x]=chosen[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=last[x];i;i=nxt[i]) floodfill(tov[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">two_sat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;scc_cnt;++x) <span class="keyword">if</span> (!deg[x]) q.push(x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x;!q.empty();)</span><br><span class="line">&#123;</span><br><span class="line">x=q.front(),q.pop();</span><br><span class="line"><span class="keyword">if</span> (!vis[x]) vis[x]=<span class="number">1</span>,chosen[x]=<span class="number">0</span>,floodfill(bel[nd[x]^<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=last[x],y;i;i=nxt[i])</span><br><span class="line"><span class="keyword">if</span> (!--deg[y=tov[i]]) q.push(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiddenRabbits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; whereAreTheRabbits(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; p, <span class="keyword">int</span> m, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; r, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; b, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; x)</span><br><span class="line">&#123;</span><br><span class="line">n=(<span class="keyword">int</span>)p.size()+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) edge[i].push_back(mkp(p[i<span class="number">-1</span>],i<span class="number">-1</span>&lt;&lt;<span class="number">1</span>)),edge[p[i<span class="number">-1</span>]].push_back(mkp(i,i<span class="number">-1</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;n;++x) fa[x][x]=<span class="number">-1</span>,dfs(x,fa[x],fe[x]);</span><br><span class="line">v=m*(n<span class="number">-1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;n;++x)</span><br><span class="line"><span class="keyword">for</span> (data e:edge[x])</span><br><span class="line"><span class="keyword">for</span> (data e_:edge[e.ft])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (e_.ft==x) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> p=node(i,e.sd),q=node(i,e_.sd);</span><br><span class="line">insert(q,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)r.size();++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (r[i]!=x[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> e=fe[r[i]][x[i]],p=node(a[i],e),q=node(b[i],e);</span><br><span class="line">insert(p^<span class="number">1</span>,p),insert(q^<span class="number">1</span>,q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (data e:edge[x[i]])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (e.ft==fa[r[i]][x[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> p=node(a[i],e.sd),q=node(b[i],e.sd);</span><br><span class="line">insert(p,q^<span class="number">1</span>),insert(q,p^<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">idx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;v;++x) <span class="keyword">if</span> (!DFN[x]) tarjan(x);</span><br><span class="line"><span class="keyword">int</span> tot_=tot;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;v;++x) last[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;tot;nxt[tot--]=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=tot_;++i) <span class="keyword">if</span> ((x=bel[edge_tmp[i][<span class="number">0</span>]])!=(y=bel[edge_tmp[i][<span class="number">1</span>]])) insert(x,y,<span class="number">0</span>),++deg[y];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;v;x+=<span class="number">2</span>) <span class="keyword">if</span> (bel[x]==bel[x^<span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">two_sat();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,x;i&lt;m;++i)</span><br><span class="line">&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">bool</span> found=<span class="number">1</span>;found;)</span><br><span class="line">&#123;</span><br><span class="line">found=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (data e:edge[x])</span><br><span class="line"><span class="keyword">if</span> (e.ft!=fa[<span class="number">0</span>][x])</span><br><span class="line"><span class="keyword">if</span> (chosen[bel[node(i,e.sd)]])</span><br><span class="line">&#123;</span><br><span class="line">x=e.ft,found=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一棵 $n$ 个节点的无根树。&lt;br&gt;你需要构造一个函数 $f:[m]\rightarrow T$ 满足若干个形如 $(r_i,a_i,b_i,x_i)$ 的限制。&lt;br&gt;一个限制表示当 $r_i$ 为根的时候，$\operatorname{LCA}\left(f(a_i),f(b_i)\right)=x_i$。&lt;/p&gt;
&lt;p&gt;$2\leq n\leq251,2\leq m\leq 250$&lt;br&gt;限制的个数 $\leq 250$&lt;br&gt;
    
    </summary>
    
    
      <category term="TopCoder" scheme="http://yoursite.com/tags/TopCoder/"/>
    
      <category term="2-SAT" scheme="http://yoursite.com/tags/2-SAT/"/>
    
  </entry>
  
  <entry>
    <title>CERC2016 I, Invisible Integers</title>
    <link href="http://yoursite.com/2018/05/24/cerc2016-i/"/>
    <id>http://yoursite.com/2018/05/24/cerc2016-i/</id>
    <published>2018-05-24T00:24:45.000Z</published>
    <updated>2018-06-15T13:16:21.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>对一个包含若干 $1$ 到 $9$ 之间的整数的序列，我们可以用以下方法生成若干条提示：</p><ol><li>随机选择序列中的一个位置作为起点。</li><li>随机选择一个方向（左/右）。</li><li>从起点开始沿着选定的方向走，遍历完这个方向的每个数字，将每个数字第一次出现的顺序记录下来。</li></ol><p>现在给定 $n$ 条提示，请找到长度最短的满足条件的整数序列。</p><p>$1\leq n\leq 10$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>不妨先考虑假如所有的提示都是从左向右的怎么做。<br>首先不难发现，提示 $y$ 能比提示 $x$ 晚出现，当且仅当 $y$ 中所有数都在 $x$ 中出现。<br>考虑从左往右匹配的过程，可以观察到提示之间可能存在类似“转化”的关系。<br>定义提示 $x$ 在第 $i$ 位之后可以转化成提示 $y$，当且仅当：</p><ol><li>到目前为止，提示 $x$ 前 $i$ 位数字都已经被匹配了。</li><li>提示 $y$ 能比提示 $x$ 晚出现。</li><li>提示 $x$ 第 $i$ 位后面的数字，在提示 $y$ 中出现的相对顺序不变。</li></ol><p>可以观察到，如果提示 $x$ 在第 $i$ 位之后可以转化成提示 $y$，那么后面我们继续填数时就可以忽略掉提示 $x$ 是否被满足，因为在这时提示 $x$ 被满足的条件已经严格弱于提示 $y$ 被满足的条件。</p><p>有了这个思路，我们可以得到一个顺序的 $dp$ 算法，令 $f_{s,x,i}$ 表示当前所有被转化过的提示集合为 $s$、当前最后转化到提示编号为 $x$、这个提示匹配到的位置为 $i$ 的状态下，序列长度的最小值。<br>每次我们枚举最后一维新加入的数字，显然这个数字要么是匹配的下一位，要么是当前提示前 $i$ 位数字中的一个。</p><p>接下来考虑从右向左的提示，可以发现我们只需要在原来基础上加多两维，分别记录当前从右向左的提示最后转移到了提示 $y$，这个提示匹配到的位置 $j$（从右向左）。转移依然是和只考虑一种方向时候的类似的。</p><p>时间复杂度 $O\left(2^n\times (dn)^2\times (n+d)\right)$。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=<span class="number">1</span>&lt;&lt;N;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> D=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=N*D+<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> transition[N+<span class="number">1</span>][D+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[S][N+<span class="number">1</span>][D+<span class="number">1</span>][N+<span class="number">1</span>][D+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> exist[N+<span class="number">1</span>][D+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hint[N+<span class="number">1</span>][D];</span><br><span class="line"><span class="keyword">int</span> len[N+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">transitive</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (~exist[x][len[x]]&amp;(y==n?<span class="number">0</span>:exist[y][len[y]])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len[y]&amp;&amp;p&lt;len[x];++i) p+=hint[x][p]==hint[y][i];</span><br><span class="line"><span class="keyword">return</span> p==len[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> l,<span class="keyword">int</span> curl,<span class="keyword">int</span> r,<span class="keyword">int</span> curr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s==(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>&amp;&amp;!curl&amp;&amp;curr==len[r]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (~f[s][l][curl][r][curr]) <span class="keyword">return</span> f[s][l][curl][r][curr];</span><br><span class="line"><span class="keyword">int</span> ret=INF;</span><br><span class="line"><span class="keyword">if</span> (l&lt;n&amp;&amp;!curl)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l_=<span class="number">0</span>;l_&lt;=n;++l_)</span><br><span class="line"><span class="keyword">if</span> (s&gt;&gt;l_&amp;<span class="number">1</span>^<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> curl_=<span class="number">0</span>;curl_&lt;=len[l_];++curl_)</span><br><span class="line"><span class="keyword">if</span> (transition[l_][curl_][l])</span><br><span class="line">ret=min(ret,dp(l_==n?s:s|<span class="number">1</span>&lt;&lt;l_,l_,curl_,r,curr));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r_=<span class="number">0</span>;r_&lt;n;++r_)</span><br><span class="line"><span class="keyword">if</span> ((s&gt;&gt;r_&amp;<span class="number">1</span>^<span class="number">1</span>)&amp;&amp;transition[r][curr][r_])</span><br><span class="line">ret=min(ret,dp(s|<span class="number">1</span>&lt;&lt;r_,l,curl,r_,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d=<span class="number">1</span>;d&lt;=D;++d)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (curl&amp;&amp;curr&lt;len[r]&amp;&amp;hint[l][curl<span class="number">-1</span>]==d&amp;&amp;hint[r][curr]==d) ret=min(ret,dp(s,l,curl<span class="number">-1</span>,r,curr+<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (curl&amp;&amp;hint[l][curl<span class="number">-1</span>]==d&amp;&amp;(exist[r][curr]&gt;&gt;d&amp;<span class="number">1</span>)) ret=min(ret,dp(s,l,curl<span class="number">-1</span>,r,curr)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (curr&lt;len[r]&amp;&amp;hint[r][curr]==d&amp;&amp;(exist[l][curl]&gt;&gt;d&amp;<span class="number">1</span>)) ret=min(ret,dp(s,l,curl,r,curr+<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[s][l][curl][r][curr]=ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"invint.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"invint.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x;x=read();)</span><br><span class="line">hint[i][len[i]++]=x;</span><br><span class="line">len[n]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=len[i];++j)</span><br><span class="line"><span class="keyword">if</span> (i==n) exist[i][j]=(<span class="number">1</span>&lt;&lt;D+<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> exist[i][j]=(j?exist[i][j<span class="number">-1</span>]|<span class="number">1</span>&lt;&lt;hint[i][j<span class="number">-1</span>]:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=len[i];++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;++k)</span><br><span class="line"><span class="keyword">if</span> (i!=k) transition[i][j][k]=i==n||transitive(i,j,k);</span><br><span class="line">ans=INF,<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) ans=min(ans,dp(i==n?<span class="number">0</span>:<span class="number">1</span>&lt;&lt;i,i,len[i],n,<span class="number">0</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans==INF?<span class="number">-1</span>:ans);</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;对一个包含若干 $1$ 到 $9$ 之间的整数的序列，我们可以用以下方法生成若干条提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随机选择序列中的一个位置作为起点。&lt;/li&gt;
&lt;li&gt;随机选择一个方向（左/右）。&lt;/li&gt;
&lt;li&gt;从起点开始沿着选定的方向走，遍历完这个方向的每个数字，将每个数字第一次出现的顺序记录下来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在给定 $n$ 条提示，请找到长度最短的满足条件的整数序列。&lt;/p&gt;
&lt;p&gt;$1\leq n\leq 10$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="bitmasks" scheme="http://yoursite.com/tags/bitmasks/"/>
    
      <category term="状压动态规划" scheme="http://yoursite.com/tags/%E7%8A%B6%E5%8E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="预处理" scheme="http://yoursite.com/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
      <category term="CERC" scheme="http://yoursite.com/tags/CERC/"/>
    
      <category term="ACM-ICPC" scheme="http://yoursite.com/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>CodeChef May Challenge 2018 Division 1 Solutions</title>
    <link href="http://yoursite.com/2018/05/16/codechef-MAY18A/"/>
    <id>http://yoursite.com/2018/05/16/codechef-MAY18A/</id>
    <published>2018-05-16T13:29:32.000Z</published>
    <updated>2018-05-24T23:27:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大概是退役前最后一次 CC 马拉松了？接下来几个月并不知道有没有时间打。<br>蹭着几何大原题打到了 rank13 ，多项式依然很菜，突击了好多 SERSUM 的必备知识，却没有时间写。<br>最后差 10 的 Rating 就可以红了？CC 的 Rating 机制还是 naive 啊，每一场划划水就能慢慢续到红名了。<a id="more"></a></p><hr><h1 id="DBFB"><a href="#DBFB" class="headerlink" title="DBFB"></a>DBFB</h1><p>傻逼题不解释。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fib[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[M],b[M];</span><br><span class="line"><span class="keyword">int</span> n,m,T,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"dbfb.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"dbfb.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">for</span> (T=read();T--;)</span><br><span class="line">&#123;</span><br><span class="line">m=read(),n=read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) a[i]=read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) b[i]=read();</span><br><span class="line">fib[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>,fib[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i) fib[i][<span class="number">0</span>]=(fib[i<span class="number">-2</span>][<span class="number">0</span>]+fib[i<span class="number">-1</span>][<span class="number">0</span>])%P,fib[i][<span class="number">1</span>]=(fib[i<span class="number">-2</span>][<span class="number">1</span>]+fib[i<span class="number">-1</span>][<span class="number">1</span>])%P;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) (ans+=<span class="number">1l</span>l*a[i]*fib[n][<span class="number">0</span>]%P*m%P)%=P,(ans+=<span class="number">1l</span>l*b[i]*fib[n][<span class="number">1</span>]%P*m%P)%=P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="FAKEBS"><a href="#FAKEBS" class="headerlink" title="FAKEBS"></a>FAKEBS</h1><p>经过的位置是固定的，直接贪心检测就好了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line"><span class="keyword">for</span> (;x;x/=<span class="number">10</span>) buf[++buf[<span class="number">0</span>]]=x%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (!buf[<span class="number">0</span>]) buf[++buf[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;buf[<span class="number">0</span>];<span class="built_in">putchar</span>(<span class="string">'0'</span>+buf[buf[<span class="number">0</span>]--]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> T,n,q;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; exist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"fakebs.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"fakebs.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">for</span> (T=read();T--;)</span><br><span class="line">&#123;</span><br><span class="line">n=read(),q=read(),exist.clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) exist[a[i]=read()]=i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) b[i]=a[i];</span><br><span class="line">sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x,l,r,rk,pos,ans0,ans1,cnt0,cnt1;q--;)</span><br><span class="line">&#123;</span><br><span class="line">x=read(),l=<span class="number">1</span>,r=n,rk=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid;l&lt;=r;)</span><br><span class="line">&#123;</span><br><span class="line">mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (b[mid]&lt;=x) l=(rk=mid)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos=exist[x],l=<span class="number">1</span>,r=n,ans0=ans1=cnt0=cnt1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid;l&lt;=r;)</span><br><span class="line">&#123;</span><br><span class="line">mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pos==mid) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;mid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[mid]&lt;x) ++ans1;</span><br><span class="line">++cnt1,r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[mid]&gt;x) ++ans0;</span><br><span class="line">++cnt0,l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt0&lt;rk&amp;&amp;cnt1&lt;=n-rk) write(max(ans0,ans1));</span><br><span class="line"><span class="keyword">else</span> write(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="CHSIGN"><a href="#CHSIGN" class="headerlink" title="CHSIGN"></a>CHSIGN</h1><p>发现一些简单的性质然后直接 $dp$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line"><span class="keyword">for</span> (;x;x/=<span class="number">10</span>) buf[++buf[<span class="number">0</span>]]=x%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (!buf[<span class="number">0</span>]) buf[++buf[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;buf[<span class="number">0</span>];<span class="built_in">putchar</span>(<span class="string">'0'</span>+buf[buf[<span class="number">0</span>]--]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL INF=LLONG_MAX&gt;&gt;<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f_[N][<span class="number">2</span>],g_[N];</span><br><span class="line">LL f[N][<span class="number">2</span>],g[N];</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> T,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=(x&gt;<span class="number">1</span>?a[x<span class="number">-1</span>]:<span class="number">0</span>)+(x&lt;n?a[x+<span class="number">1</span>]:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> sum&lt;a[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generatef</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">bool</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateg</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generatef</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">bool</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">b[x]=a[x];</span><br><span class="line"><span class="keyword">if</span> (x==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (sig) generatef(x<span class="number">-1</span>,f_[x][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">b[x<span class="number">-1</span>]=-a[x<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span> (f_[x][<span class="number">0</span>]) generatef(x<span class="number">-2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> generateg(x<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateg</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">b[x]=a[x];</span><br><span class="line"><span class="keyword">if</span> (x==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">b[x<span class="number">-1</span>]=-a[x<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span> (g_[x]) generatef(x<span class="number">-2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> generateg(x<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i][<span class="number">0</span>]=f[i][<span class="number">1</span>]=g[i]=INF;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">0</span>]=g[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>]&lt;a[<span class="number">2</span>]) f[<span class="number">2</span>][<span class="number">0</span>]=g[<span class="number">2</span>]=a[<span class="number">2</span>]-a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (f[i+<span class="number">1</span>][<span class="number">1</span>]&gt;f[i][<span class="number">0</span>]+a[i+<span class="number">1</span>]) f[i+<span class="number">1</span>][<span class="number">1</span>]=f[i][<span class="number">0</span>]+a[i+<span class="number">1</span>],f_[i+<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (f[i+<span class="number">1</span>][<span class="number">1</span>]&gt;f[i][<span class="number">1</span>]+a[i+<span class="number">1</span>]) f[i+<span class="number">1</span>][<span class="number">1</span>]=f[i][<span class="number">1</span>]+a[i+<span class="number">1</span>],f_[i+<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!judge(i)) g[i]=INF;</span><br><span class="line"><span class="keyword">if</span> (i+<span class="number">2</span>&gt;n||a[i+<span class="number">1</span>]&gt;=a[i]||a[i+<span class="number">1</span>]&gt;=a[i+<span class="number">2</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (f[i+<span class="number">2</span>][<span class="number">0</span>]&gt;f[i][<span class="number">1</span>]-a[i+<span class="number">1</span>]+a[i+<span class="number">2</span>]) f[i+<span class="number">2</span>][<span class="number">0</span>]=f[i][<span class="number">1</span>]-a[i+<span class="number">1</span>]+a[i+<span class="number">2</span>],f_[i+<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (g[i+<span class="number">2</span>]&gt;f[i][<span class="number">1</span>]-a[i+<span class="number">1</span>]+a[i+<span class="number">2</span>]) g[i+<span class="number">2</span>]=f[i][<span class="number">1</span>]-a[i+<span class="number">1</span>]+a[i+<span class="number">2</span>],g_[i+<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (g[i+<span class="number">2</span>]&gt;g[i]-a[i+<span class="number">1</span>]+a[i+<span class="number">2</span>]) g[i+<span class="number">2</span>]=g[i]-a[i+<span class="number">1</span>]+a[i+<span class="number">2</span>],g_[i+<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (f[i+<span class="number">2</span>][<span class="number">0</span>]&gt;g[i]-a[i+<span class="number">1</span>]+a[i+<span class="number">2</span>]) f[i+<span class="number">2</span>][<span class="number">0</span>]=g[i]-a[i+<span class="number">1</span>]+a[i+<span class="number">2</span>],f_[i+<span class="number">2</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!judge(n)) g[n]=INF;</span><br><span class="line">LL ans0=f[n][<span class="number">1</span>],ans1=a[n]&gt;=a[n<span class="number">-1</span>]?INF:f[n<span class="number">-1</span>][<span class="number">1</span>]-a[n],ans2=g[n],ans3=a[n]&gt;=a[n<span class="number">-1</span>]?INF:g[n<span class="number">-1</span>]-a[n];</span><br><span class="line"><span class="keyword">if</span> (ans0&lt;=ans1&amp;&amp;ans0&lt;=ans2&amp;&amp;ans0&lt;=ans3) generatef(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ans1&lt;=ans0&amp;&amp;ans1&lt;=ans2&amp;&amp;ans1&lt;=ans3) b[n]=-a[n],generatef(n<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ans2&lt;=ans0&amp;&amp;ans2&lt;=ans1&amp;&amp;ans2&lt;=ans3) generateg(n);</span><br><span class="line"><span class="keyword">else</span> b[n]=-a[n],generateg(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"chsign.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"chsign.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">for</span> (T=read();T--;)</span><br><span class="line">&#123;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=read();</span><br><span class="line">dp();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) write(b[i]),<span class="built_in">putchar</span>(<span class="string">"\n "</span>[i&lt;n]);</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="STMINCUT"><a href="#STMINCUT" class="headerlink" title="STMINCUT"></a>STMINCUT</h1><p>直接造一个最大生成树，所有边补齐成路径最大值。<br>为什么是对的？结合最小割树的性质感受一下（划掉）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=INT_MAX&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> E=N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=N*N;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> tov[E],nxt[E],len[E];</span><br><span class="line"><span class="keyword">int</span> a[N][N],d[N][N];</span><br><span class="line"><span class="keyword">int</span> last[N],fa[N];</span><br><span class="line"><span class="keyword">int</span> T,n,tot,ecnt;</span><br><span class="line">LL ans;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,len;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">edge</span> <span class="params">(<span class="keyword">int</span> x_=<span class="number">0</span>,<span class="keyword">int</span> y_=<span class="number">0</span>,<span class="keyword">int</span> len_=<span class="number">0</span>)</span></span>&#123;x=x_,y=y_,len=len_;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(edge <span class="keyword">const</span> e)<span class="keyword">const</span>&#123;<span class="keyword">return</span> len&gt;e.len;&#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;tov[++tot]=y,len[tot]=z,nxt[tot]=last[x],last[x]=tot;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfather</span><span class="params">(<span class="keyword">int</span> son)</span></span>&#123;<span class="keyword">return</span> fa[son]==son?son:fa[son]=getfather(fa[son]);&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruscal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sort(e+<span class="number">1</span>,e+<span class="number">1</span>+ecnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x) fa[x]=x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y,fx,fy;i&lt;=ecnt;++i)</span><br><span class="line">&#123;</span><br><span class="line">fx=getfather(x=e[i].x),fy=getfather(y=e[i].y);</span><br><span class="line"><span class="keyword">if</span> (fx!=fy) insert(x,y,e[i].len),insert(y,x,e[i].len),fa[fy]=fx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> cur,<span class="keyword">int</span> *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[x]=cur;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=last[x],y;i;i=nxt[i])</span><br><span class="line"><span class="keyword">if</span> ((y=tov[i])!=fa) dfs(y,x,min(cur,len[i]),d);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"stmincut.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"stmincut.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">for</span> (T=read();T--;)</span><br><span class="line">&#123;</span><br><span class="line">n=read(),ecnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">e[++ecnt]=edge(i,j,a[i][j]=read());</span><br><span class="line">Kruscal();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x) dfs(x,<span class="number">0</span>,INF,d[x]);</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line"><span class="keyword">if</span> (i!=j) ans+=d[i][j]-a[i][j];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">for</span> (;tot;nxt[tot--]=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x) last[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="EDGEST"><a href="#EDGEST" class="headerlink" title="EDGEST"></a>EDGEST</h1><p>中规中矩的很套路的数据结构题。<br>“中国人玩烂的东西印度人玩。”——不知道谁说的<br>考虑只有第一个限制，我们可以通过 DFS 序+线段树来做。<br>加入第二个限制之后，我们通过 DFS +线段树合并来保证第一个限制，至于第二个限制，我们将第二棵树中的边，在第一棵树的对应端点都挂上 $+1$ 标记，在 $lca$ 处挂上 $-2$ 标记。然后处理标记的时候相当于在第二棵树对应位置单点加，查询的时候是路径查询，这个可以写树剖，也可以直接用欧拉序来维护。<br>时间复杂度 $O(n\log n)$ 吧。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">30</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line"><span class="keyword">for</span> (;x;x/=<span class="number">10</span>) buf[++buf[<span class="number">0</span>]]=x%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (!buf[<span class="number">0</span>]) buf[++buf[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;buf[<span class="number">0</span>];<span class="built_in">putchar</span>(<span class="string">'0'</span>+buf[buf[<span class="number">0</span>]--]));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LGN=<span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> E=N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> EL=N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LGEL=<span class="number">19</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_EVT=N*<span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> app[N],ext[N],head[N],root[N],LOG[N],ans[N];</span><br><span class="line"><span class="keyword">int</span> adj[MAX_EVT],stp[MAX_EVT];</span><br><span class="line"><span class="keyword">bool</span> sig[MAX_EVT];</span><br><span class="line"><span class="keyword">int</span> T,n,el,evt_cnt;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> last[N],depth[N];</span><br><span class="line"><span class="keyword">int</span> anc[N][LGN];</span><br><span class="line"><span class="keyword">int</span> tov[E],nxt[E];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=last[x],y;i;i=nxt[i])</span><br><span class="line"><span class="keyword">if</span> ((y=tov[i])!=anc[x][<span class="number">0</span>])</span><br><span class="line">depth[y]=depth[anc[y][<span class="number">0</span>]=x]+<span class="number">1</span>,dfs(y);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=LOG[n];++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x)</span><br><span class="line">anc[x][i]=anc[anc[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=LOG[depth[x]];i&gt;=<span class="number">0</span>;--i) <span class="keyword">if</span> (depth[anc[x][i]]&gt;=h) x=anc[x][i];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (depth[x]&gt;=depth[y]) swap(x,y);</span><br><span class="line">y=adjust(y,depth[x]);</span><br><span class="line"><span class="keyword">if</span> (x==y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=LOG[depth[x]];i&gt;=<span class="number">0</span>;--i) <span class="keyword">if</span> (anc[x][i]!=anc[y][i]) x=anc[x][i],y=anc[y][i];</span><br><span class="line"><span class="keyword">return</span> anc[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;tot;nxt[tot]=<span class="number">0</span>,--tot);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x) last[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;t[<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">bool</span> delta)</span></span>&#123;adj[++evt_cnt]=y,sig[evt_cnt]=delta,stp[evt_cnt]=head[x],head[x]=evt_cnt;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">app[x]=++el;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=t[<span class="number">1</span>].last[x],y;i;i=t[<span class="number">1</span>].nxt[i])</span><br><span class="line"><span class="keyword">if</span> ((y=t[<span class="number">1</span>].tov[i])!=t[<span class="number">1</span>].anc[x][<span class="number">0</span>])</span><br><span class="line">travel(y);</span><br><span class="line">ext[x]=++el;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> segment_tree</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V=EL*LGEL;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> son[V][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> sum[V];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> st,<span class="keyword">int</span> en,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!rt||st&gt;en) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (st==l&amp;&amp;en==r) <span class="keyword">return</span> sum[rt];</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (en&lt;=mid) <span class="keyword">return</span> query(son[rt][<span class="number">0</span>],st,en,l,mid);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid+<span class="number">1</span>&lt;=st) <span class="keyword">return</span> query(son[rt][<span class="number">1</span>],st,en,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(son[rt][<span class="number">0</span>],st,mid,l,mid)+query(son[rt][<span class="number">1</span>],mid+<span class="number">1</span>,en,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!rt) sum[rt=++tot]=<span class="number">0</span>,son[rt][<span class="number">0</span>]=son[rt][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">sum[rt]+=delta;</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x&lt;=mid) modify(son[rt][<span class="number">0</span>],x,l,mid,delta);</span><br><span class="line"><span class="keyword">else</span> modify(son[rt][<span class="number">1</span>],x,mid+<span class="number">1</span>,r,delta);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> rt0,<span class="keyword">int</span> rt1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!rt0||!rt1) <span class="keyword">return</span> rt0^rt1;</span><br><span class="line">sum[rt0]+=sum[rt1],son[rt0][<span class="number">0</span>]=merge(son[rt0][<span class="number">0</span>],son[rt1][<span class="number">0</span>]),son[rt0][<span class="number">1</span>]=merge(son[rt0][<span class="number">1</span>],son[rt1][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> rt0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_path</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> z=t[<span class="number">1</span>].lca(x,y);</span><br><span class="line"><span class="keyword">return</span> segment_tree::query(rt,<span class="number">1</span>,app[x],<span class="number">1</span>,el)+segment_tree::query(rt,<span class="number">1</span>,app[y],<span class="number">1</span>,el)-(segment_tree::query(rt,<span class="number">1</span>,app[z],<span class="number">1</span>,el)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> e=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">root[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=t[<span class="number">0</span>].last[x],y;i;i=t[<span class="number">0</span>].nxt[i])</span><br><span class="line"><span class="keyword">if</span> ((y=t[<span class="number">0</span>].tov[i])!=t[<span class="number">0</span>].anc[x][<span class="number">0</span>])</span><br><span class="line">calc(y,i+<span class="number">1</span>&gt;&gt;<span class="number">1</span>),root[x]=segment_tree::merge(root[x],root[y]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=head[x],y;i;i=stp[i]) y=adj[i],segment_tree::modify(root[x],app[y],<span class="number">1</span>,el,sig[i]?<span class="number">1</span>:<span class="number">-2</span>),segment_tree::modify(root[x],ext[y],<span class="number">1</span>,el,sig[i]?<span class="number">-1</span>:<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (t[<span class="number">0</span>].anc[x][<span class="number">0</span>]) ans[e]=query_path(root[x],x,t[<span class="number">0</span>].anc[x][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleardata</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[<span class="number">0</span>].clear(),t[<span class="number">1</span>].clear();</span><br><span class="line"><span class="keyword">for</span> (;evt_cnt;stp[evt_cnt]=<span class="number">0</span>,--evt_cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x) head[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"edgest.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"edgest.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">for</span> (T=read();T--;cleardata())</span><br><span class="line">&#123;</span><br><span class="line">n=read(),LOG[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) LOG[i]=LOG[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;LOG[i<span class="number">-1</span>]+<span class="number">1</span>==i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;<span class="number">2</span>;++s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i) x=read(),y=read(),t[s].insert(x,y),t[s].insert(y,x);</span><br><span class="line">t[s].depth[<span class="number">1</span>]=<span class="number">1</span>,t[s].dfs(<span class="number">1</span>),t[s].pre();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">2</span>,y;x&lt;=n;++x) y=t[<span class="number">1</span>].anc[x][<span class="number">0</span>],add_event(x,x,<span class="number">1</span>),add_event(y,x,<span class="number">1</span>),add_event(t[<span class="number">0</span>].lca(x,y),x,<span class="number">0</span>);</span><br><span class="line">el=<span class="number">0</span>,travel(<span class="number">1</span>),segment_tree::tot=<span class="number">0</span>,calc(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) write(ans[i]),<span class="built_in">putchar</span>(<span class="string">"\n "</span>[i&lt;n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="RUBBER"><a href="#RUBBER" class="headerlink" title="RUBBER"></a>RUBBER</h1><p>大原题，<a href="http://codeforces.com/blog/entry/10690" target="_blank" rel="noopener">这里</a> 有详细讲解。<br><a href="http://www.opencup.ru/files/oce/gp8/problems-e.pdf" target="_blank" rel="noopener">XIV Open Cup named after E.V. Pankratiev, Grand Prix of Udmurtia, Division 1, Problem B, Black hole</a><br>有一道在这个思想上加强的题目<br><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1164" target="_blank" rel="noopener">ACM International Collegiate Programming Contest, Japan Domestic Contest, Tokyo, Japan, Problem F, Tighten Up!</a><br>考虑现实意义中缩进橡皮筋的过程，其实就是将一些无用的拐角删除。<br>我们过每个钉子做一条竖直线，分成上下两条射线，对每一条射线编号。<br>射线穿过多边形折线的时候，在对应位置写上射线的编号。<br>从任意位置开始按顺序遍历多边形折线，将沿途的编号记录下来，可以发现，所谓的无用的拐角，就是相邻两个一样的数。<br>每次删掉相邻两个一样的数，如果最后可以拿走橡皮筋，那么一定没有数剩下。使用栈实现一下就好了。<br>时间复杂度 $O(nm)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> db;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">3005</span>;</span><br><span class="line"><span class="keyword">const</span> db EPS=<span class="number">1e-8</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equ</span><span class="params">(db x,db y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">fabs</span>(x-y)&lt;EPS;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sgn</span><span class="params">(db x)</span></span>&#123;<span class="keyword">return</span> equ(x,<span class="number">0.</span>)?<span class="number">0</span>:(x&lt;<span class="number">0</span>?<span class="number">-1</span>:<span class="number">1</span>);&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">db x,y;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">P</span> <span class="params">(db x_=<span class="number">0.</span>,db y_=<span class="number">0.</span>)</span></span>&#123;x=x_,y=y_;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(P <span class="keyword">const</span> p)<span class="keyword">const</span>&#123;<span class="keyword">return</span> sgn(x-p.x)&lt;<span class="number">0</span>||!sgn(x-p.x)&amp;&amp;sgn(y-p.y)&lt;<span class="number">0</span>;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> P <span class="keyword">operator</span>+(P <span class="keyword">const</span> p)<span class="keyword">const</span>&#123;<span class="keyword">return</span> P(x+p.x,y+p.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> P <span class="keyword">operator</span>-(P <span class="keyword">const</span> p)<span class="keyword">const</span>&#123;<span class="keyword">return</span> P(x-p.x,y-p.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> P <span class="keyword">operator</span>*(db <span class="keyword">const</span> k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> P(x*k,y*k);&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> db <span class="keyword">operator</span>*(P <span class="keyword">const</span> p)<span class="keyword">const</span>&#123;<span class="keyword">return</span> x*p.x+y*p.y;&#125;</span><br><span class="line"><span class="keyword">inline</span> db <span class="keyword">operator</span>^(P <span class="keyword">const</span> p)<span class="keyword">const</span>&#123;<span class="keyword">return</span> x*p.y-y*p.x;&#125;</span><br><span class="line">&#125;nail[N],rub[M];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> P <span class="title">rotate</span><span class="params">(P p,db a)</span></span>&#123;<span class="keyword">return</span> P(p.x*<span class="built_in">cos</span>(a)-p.y*<span class="built_in">sin</span>(a),p.x*<span class="built_in">sin</span>(a)+p.y*<span class="built_in">cos</span>(a));&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[N*M];</span><br><span class="line"><span class="keyword">int</span> T,n,m,top;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">top=<span class="number">0</span>,rub[<span class="number">0</span>]=rub[m];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line"><span class="keyword">if</span> (sgn(rub[i].x-rub[i<span class="number">-1</span>].x)&gt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sgn(rub[i].x-nail[j].x)&gt;<span class="number">0</span>&amp;&amp;sgn(nail[j].x-rub[i<span class="number">-1</span>].x)&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">P p=(rub[i]-rub[i<span class="number">-1</span>])*((nail[j].x-rub[i<span class="number">-1</span>].x)/(rub[i].x-rub[i<span class="number">-1</span>].x))+rub[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span> (sgn(nail[j].y-p.y)&gt;<span class="number">0</span>) <span class="built_in">stack</span>[++top]=(j&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">stack</span>[++top]=j&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;top&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="built_in">stack</span>[top<span class="number">-1</span>];top-=<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=n;j&gt;=<span class="number">1</span>;--j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sgn(nail[j].x-rub[i].x)&gt;<span class="number">0</span>&amp;&amp;sgn(rub[i<span class="number">-1</span>].x-nail[j].x)&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">P p=(rub[i]-rub[i<span class="number">-1</span>])*((nail[j].x-rub[i<span class="number">-1</span>].x)/(rub[i].x-rub[i<span class="number">-1</span>].x))+rub[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span> (sgn(nail[j].y-p.y)&gt;<span class="number">0</span>) <span class="built_in">stack</span>[++top]=(j&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">stack</span>[++top]=j&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;top&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="built_in">stack</span>[top<span class="number">-1</span>];top-=<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"rubber.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"rubber.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);T--;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;<span class="keyword">double</span> x,y;<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;x,&amp;y),nail[i]=rotate(P(x,y),<span class="number">0.233</span>);&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;<span class="keyword">double</span> x,y;<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;x,&amp;y),rub[i]=rotate(P(x,y),<span class="number">0.233</span>);&#125;</span><br><span class="line">sort(nail+<span class="number">1</span>,nail+<span class="number">1</span>+n),judge();</span><br><span class="line"><span class="built_in">printf</span>(top?<span class="string">"NO\n"</span>:<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="SERSUM"><a href="#SERSUM" class="headerlink" title="SERSUM"></a>SERSUM</h1><p>这道题集齐了目前为止学过的几乎所有的多项式/生成函数姿势（还有不少是临时突击的）。<br>式子其实很好推：<br>$$<br>\begin{align}<br>f(x,k)&amp;=\sum_{i=1}^n(x+a_i)^k\<br>&amp;=\sum_{i=1}^n\sum_{j=0}^kx^ja_i^{k-j}{k\choose j}\<br>&amp;=\sum_{j=0}^kx^j{k\choose j}\sum_{i=1}^na_i^{k-j}<br>\end{align}<br>$$记 $f_k=\sum_{i=1}^na_i^k$，我们有 $f(x,k)=\sum_{j=0}^kx^j{k\choose j}f_{k-j}$。<br>然后继续推：<br>$$<br>\begin{align}<br>g(t,k)&amp;=\sum_{i=0}^tf(i,k)\<br>&amp;=\sum_{i=0}^t\sum_{j=0}^ki^j{k\choose j}f_{k-j}\<br>&amp;=\sum_{j=0}^k{k\choose j}f_{k-j}\sum_{i=0}^ti^j<br>\end{align}<br>$$记 $S_k=\sum_{i=0}^ti^k$，我们有 $g(t,k)=\sum_{j=0}^k{k\choose j}f_{k-j}S_j$。<br>如果我们可以算出 $f_i$ 和 $S_i$ 的值，那么求 $g(t,0…k)$ 就是一个卷积搞定。<br>先来看求 $S_i$，这个是个经典问题，考虑使用 Bernoulli 数：<br>$$<br>\sum_{i=0}^{n-1}i^k=\frac1{k+1}\sum_{i=0}^k{k+1\choose i}B_in^{k+1-i}<br>$$要求出 $0…n-1$ 的所有自然数 $0…k$ 次幂之和，依然是一个卷积搞定。<br>然后比较难的是求出 $f_i$，即给定序列所有元素的次幂和。这个其实就是 THUPC2017 的 I 题 <a href="https://git.thusaac.org/publish/THUPC2017/tree/master/day1/sum" target="_blank" rel="noopener">sum</a>。<br>定义 $g_i$ 表示从序列中选出 $i$ 个不同元素的乘积之和（当 $i&gt;n$ 时为 $0$），这个可以使用分治 FFT 来预处理。<br>考虑容斥意义可以得到$$f_n=\sum_{i=1}^{n-1}(-1)^{i-1}g_if_{n-i}+(-1)^{n-1}ng_n$$考虑使用生成函数，令 $F(x)=\sum_{i=1}^nf_ix^i,G(x)=\sum_{i=1}^n(-1)^{i-1}g_ix^i,H(x)=\sum_{i=1}^n(-1)^{i-1}ig_ix^i$，于是我们就有 $F(x)=F(x)G(x)+H(x)$，即$$F(x)=\frac{H(x)}{1-G(x)}$$多项式求逆即可。<br>那么所有问题就圆满解决了，至于 FFT，当然是选择写毛爷爷的 4 次 DFT 式任意模数 FFT 啦！<br>时间复杂度 $O(n\log^2n+K\log K)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line"><span class="keyword">for</span> (;x;x/=<span class="number">10</span>) buf[++buf[<span class="number">0</span>]]=x%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (!buf[<span class="number">0</span>]) buf[++buf[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;buf[<span class="number">0</span>];<span class="built_in">putchar</span>(<span class="string">'0'</span>+buf[buf[<span class="number">0</span>]--]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK=<span class="number">50005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LG=<span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L=<span class="number">1</span>&lt;&lt;LG;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> trs[L],f[L],Ber[L],S[L],tmp[L],g[LG][L];</span><br><span class="line"><span class="keyword">int</span> fact[MAXK],invf[MAXK],pw[MAXK];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n,K,T,len;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Z</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">db x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Z</span> <span class="params">(db x_=<span class="number">0.</span>,db y_=<span class="number">0.</span>)</span></span>&#123;x=x_,y=y_;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Z <span class="keyword">operator</span>+(Z <span class="keyword">const</span> z)<span class="keyword">const</span>&#123;<span class="keyword">return</span> Z(x+z.x,y+z.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> Z <span class="keyword">operator</span>-(Z <span class="keyword">const</span> z)<span class="keyword">const</span>&#123;<span class="keyword">return</span> Z(x-z.x,y-z.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> Z <span class="keyword">operator</span>*(Z <span class="keyword">const</span> z)<span class="keyword">const</span>&#123;<span class="keyword">return</span> Z(x*z.x-y*z.y,x*z.y+y*z.x);&#125;</span><br><span class="line"><span class="keyword">inline</span> Z <span class="keyword">operator</span>/(db <span class="keyword">const</span> k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> Z(x/k,y/k);&#125;</span><br><span class="line">&#125;omega[L+<span class="number">5</span>],A[L+<span class="number">5</span>],B[L+<span class="number">5</span>],C[<span class="number">2</span>][L+<span class="number">5</span>],t[L+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Z <span class="title">conj</span><span class="params">(Z p)</span></span>&#123;<span class="keyword">return</span> Z(p.x,-p.y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%P) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) ret=<span class="number">1l</span>l*ret*x%P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K+<span class="number">1</span>;++i) fact[i]=<span class="number">1l</span>l*fact[i<span class="number">-1</span>]*i%P;</span><br><span class="line">invf[K+<span class="number">1</span>]=quick_power(fact[K+<span class="number">1</span>],P<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=K+<span class="number">1</span>;i&gt;=<span class="number">1</span>;--i) invf[i<span class="number">-1</span>]=<span class="number">1l</span>l*invf[i]*i%P;</span><br><span class="line">pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K+<span class="number">1</span>;++i) pw[i]=<span class="number">1l</span>l*pw[i<span class="number">-1</span>]*T%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT_pre</span><span class="params">()</span></span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=L;++i) omega[i]=Z(<span class="built_in">cos</span>(<span class="number">2.</span>*pi*i/L),<span class="built_in">sin</span>(<span class="number">2.</span>*pi*i/L));&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deg_pre</span><span class="params">(<span class="keyword">int</span> deg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (len=<span class="number">1</span>;len&lt;deg;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,ret;i&lt;len;++i)</span><br><span class="line">&#123;</span><br><span class="line">ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=i,j=<span class="number">1</span>;j&lt;len;j&lt;&lt;=<span class="number">1</span>,x&gt;&gt;=<span class="number">1</span>) ret=(ret&lt;&lt;<span class="number">1</span>)|(x&amp;<span class="number">1</span>);</span><br><span class="line">trs[i]=ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(Z *a,<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) t[trs[i]]=a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> l=<span class="number">2</span>;l&lt;=len;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> h=l&gt;&gt;<span class="number">1</span>,j=<span class="number">0</span>;j&lt;len;j+=l)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;++i)</span><br><span class="line">&#123;</span><br><span class="line">Z u=t[i+j],v=t[i+j+h]*omega[sig&gt;<span class="number">0</span>?L/l*i:L-L/l*i];</span><br><span class="line">t[i+j]=u+v,t[i+j+h]=u-v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=t[i];</span><br><span class="line"><span class="keyword">if</span> (sig&lt;<span class="number">0</span>) <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=a[i]/len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j;i&lt;len;++i)</span><br><span class="line">&#123;</span><br><span class="line">j=(len-i)&amp;(len<span class="number">-1</span>);Z a1=(A[i]+conj(A[j]))*Z(<span class="number">.5</span>,<span class="number">0</span>),a0=(A[i]-conj(A[j]))*Z(<span class="number">0</span>,<span class="number">-.5</span>),b1=(B[i]+conj(B[j]))*Z(<span class="number">.5</span>,<span class="number">0</span>),b0=(B[i]-conj(B[j]))*Z(<span class="number">0</span>,<span class="number">-.5</span>);</span><br><span class="line">Z dftc0=a0*b0,dftc1=a0*b1,dftc2=a1*b0,dftc3=a1*b1;</span><br><span class="line">C[<span class="number">0</span>][i]=dftc1+dftc0*Z(<span class="number">0</span>,<span class="number">1</span>),C[<span class="number">1</span>][i]=dftc3+dftc2*Z(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans</span><span class="params">(<span class="keyword">int</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> c1=(LL)(C[<span class="number">0</span>][i].x+<span class="number">.5</span>)%P,c0=(LL)(C[<span class="number">0</span>][i].y+<span class="number">.5</span>)%P,c3=(LL)(C[<span class="number">1</span>][i].x+<span class="number">.5</span>)%P,c2=(LL)(C[<span class="number">1</span>][i].y+<span class="number">.5</span>)%P;</span><br><span class="line">c[i]=(c0+((LL)(c1+c2)&lt;&lt;<span class="number">15</span>)+((LL)c3&lt;&lt;<span class="number">30</span>))%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b,<span class="keyword">int</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[i]=Z(a[i]&gt;&gt;<span class="number">15</span>,a[i]&amp;<span class="number">32767</span>),B[i]=Z(b[i]&gt;&gt;<span class="number">15</span>,b[i]&amp;<span class="number">32767</span>);</span><br><span class="line">DFT(A,<span class="number">1</span>),DFT(B,<span class="number">1</span>),merge(),DFT(C[<span class="number">0</span>],<span class="number">-1</span>),DFT(C[<span class="number">1</span>],<span class="number">-1</span>),trans(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">polynomial_inverse</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b,<span class="keyword">int</span> deg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deg==<span class="number">1</span>)&#123;b[<span class="number">0</span>]=quick_power(a[<span class="number">0</span>],P<span class="number">-2</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> deg_=deg+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;polynomial_inverse(a,b,deg_);</span><br><span class="line">deg_pre((deg&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>),copy(a,a+deg,tmp),fill(tmp+deg,tmp+len,<span class="number">0</span>),FFT(tmp,b,tmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[i]=Z(tmp[i]&gt;&gt;<span class="number">15</span>,tmp[i]&amp;<span class="number">32767</span>);</span><br><span class="line">DFT(A,<span class="number">1</span>),merge(),DFT(C[<span class="number">0</span>],<span class="number">-1</span>),DFT(C[<span class="number">1</span>],<span class="number">-1</span>),trans(tmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) b[i]=((b[i]&lt;&lt;<span class="number">1</span>)+P-tmp[i])%P;</span><br><span class="line">fill(b+deg,b+len,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_Bernoulli</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=K;++i) f[i]=invf[i+<span class="number">1</span>];</span><br><span class="line">polynomial_inverse(f,Ber,K+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_S</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K+<span class="number">1</span>;++i) f[i]=<span class="number">1l</span>l*pw[i]*invf[i]%P;</span><br><span class="line">deg_pre(K+<span class="number">1</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>),FFT(Ber,f,S);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=K;++i) S[i]=<span class="number">1l</span>l*S[i+<span class="number">1</span>]*fact[i]%P;</span><br><span class="line">fill(S+K+<span class="number">1</span>,S+len,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cur=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r)&#123;g[cur][<span class="number">0</span>]=<span class="number">1</span>,g[cur][<span class="number">1</span>]=a[l];<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,deg=r-l+<span class="number">2</span>,deg0=mid-l+<span class="number">2</span>,deg1=r-mid+<span class="number">1</span>;</span><br><span class="line">solve(l,mid,cur+<span class="number">1</span>),copy(g[cur+<span class="number">1</span>],g[cur+<span class="number">1</span>]+deg0,g[cur]);</span><br><span class="line">solve(mid+<span class="number">1</span>,r,cur+<span class="number">1</span>),deg_pre(deg),fill(g[cur]+deg0,g[cur]+len,<span class="number">0</span>),fill(g[cur+<span class="number">1</span>]+deg1,g[cur+<span class="number">1</span>]+len,<span class="number">0</span>);</span><br><span class="line">FFT(g[cur],g[cur+<span class="number">1</span>],g[cur]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sig</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;<span class="number">1</span>?P<span class="number">-1</span>:<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">solve(<span class="number">1</span>,n),g[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;i&lt;=K;++i) g[<span class="number">1</span>][i]=<span class="number">1l</span>l*g[<span class="number">0</span>][i]*sig(i)%P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=K;++i) g[<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f),polynomial_inverse(g[<span class="number">1</span>],f,K+<span class="number">1</span>),g[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;i&lt;=K;++i) g[<span class="number">1</span>][i]=<span class="number">1l</span>l*i*(P-sig(i))%P*g[<span class="number">0</span>][i]%P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=K;++i) g[<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">deg_pre(K&lt;&lt;<span class="number">1</span>|<span class="number">1</span>),fill(g[<span class="number">1</span>]+K+<span class="number">1</span>,g[<span class="number">1</span>]+len,<span class="number">0</span>),fill(f+K+<span class="number">1</span>,f+len,<span class="number">0</span>),FFT(g[<span class="number">1</span>],f,f),f[<span class="number">0</span>]=n,fill(f+K+<span class="number">1</span>,f+len,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=K;++i) S[i]=<span class="number">1l</span>l*S[i]*invf[i]%P,f[i]=<span class="number">1l</span>l*f[i]*invf[i]%P;</span><br><span class="line">deg_pre(K&lt;&lt;<span class="number">1</span>|<span class="number">1</span>),fill(f+K+<span class="number">1</span>,f+len,<span class="number">0</span>),FFT(f,S,f);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=K;++i) f[i]=<span class="number">1l</span>l*f[i]*fact[i]%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"sersum.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"sersum.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">n=read&lt;<span class="keyword">int</span>&gt;(),K=read&lt;<span class="keyword">int</span>&gt;(),T=(read&lt;LL&gt;()+<span class="number">1</span>)%P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=read&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">pre(),FFT_pre(),calc_Bernoulli(),calc_S(),calc_f(),calc();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=K;++i) write(f[i]),<span class="built_in">putchar</span>(<span class="string">"\n "</span>[i&lt;K]);</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;大概是退役前最后一次 CC 马拉松了？接下来几个月并不知道有没有时间打。&lt;br&gt;蹭着几何大原题打到了 rank13 ，多项式依然很菜，突击了好多 SERSUM 的必备知识，却没有时间写。&lt;br&gt;最后差 10 的 Rating 就可以红了？CC 的 Rating 机制还是 naive 啊，每一场划划水就能慢慢续到红名了。
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="普通动态规划" scheme="http://yoursite.com/tags/%E6%99%AE%E9%80%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="组合数" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="线段树" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="FFT/NTT/FWT" scheme="http://yoursite.com/tags/FFT-NTT-FWT/"/>
    
      <category term="构造" scheme="http://yoursite.com/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="CodeChef" scheme="http://yoursite.com/tags/CodeChef/"/>
    
      <category term="多项式" scheme="http://yoursite.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="预处理" scheme="http://yoursite.com/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
      <category term="二分法" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
      <category term="最小割树" scheme="http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91/"/>
    
      <category term="最小割" scheme="http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
      <category term="生成树" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="线段树合并" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    
      <category term="欧拉序" scheme="http://yoursite.com/tags/%E6%AC%A7%E6%8B%89%E5%BA%8F/"/>
    
      <category term="生成函数" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="容斥原理" scheme="http://yoursite.com/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
      <category term="数论" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="计算几何" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 578F Mirror Box</title>
    <link href="http://yoursite.com/2018/04/16/codeforces-578f/"/>
    <id>http://yoursite.com/2018/04/16/codeforces-578f/</id>
    <published>2018-04-16T03:46:49.000Z</published>
    <updated>2018-05-24T14:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>一个 $n\times m$ 个格子的网格图，有些格子上有双面的镜子，有些格子上没有。镜子都是呈对角线放置（ <code>/</code> 或 <code>\</code> ）。<br>现在你要在所有没有镜子的格子上摆放镜子，使得最后网格图满足下面两个条件：<br>$\bullet$ 从网格图边界上的任意一条边垂直向内射入光线，光线一定会从一条相邻边射出网格图。<br>$\bullet$ 对于网格图的中的任意一条边，都存在一种从边界处一条边垂直向内射入光线的方法，使得这条边被光线穿过。<br>求满足条件的摆放镜子的方案数。答案对 $P$ 取模。</p><p>$1\leq n,m\leq100,3\leq P\leq10^9+7,P\in\mathbb{P}$<br>空白格子个数 $K$ 不超过 $200$。<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>将格点黑白染色。可以发现，条件一中的光线围住的边界点颜色一定是一致的。<br>我们不妨假设要围住黑点。考虑将镜子看成无向边，既然光线会围住黑点，那么黑点一定是不连通的。<br>考虑条件二，每一条边都要被光线穿过，其实就是要求图不存在环。<br>那么白点又会形成什么呢？不妨在图的外面再加上一圈的镜子使得条件一中的光线实际上构成一个回路，可以发现这条回路穿过了网格图中的所有边，并且是一个简单环。假设白点不连通，那么一定是存在一条黑点构成的路径从一侧边界穿到了另一侧，这样显然不能满足前面的条件。因此白点实质上构成了一棵生成树。<br>剩下的问题就很简单了，由于空白格子最多只有 $200$，直接基尔霍夫矩阵树定理求白点生成树个数就好了。<br>对于围住白色的情况同理，再做一次类似过程就可以解决。<br>时间复杂度 $O(K^3)$。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T=<span class="number">205</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=N*N;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V=T&lt;&lt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[S],lab[S];</span><br><span class="line"><span class="keyword">char</span> MAP[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,s,P,idx,ans;</span><br><span class="line"><span class="keyword">bool</span> cir=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%P) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) ret=<span class="number">1l</span>l*ret*x%P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfather</span><span class="params">(<span class="keyword">int</span> son)</span></span>&#123;<span class="keyword">return</span> fa[son]==son?son:fa[son]=getfather(fa[son]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=getfather(x),y=getfather(y);</span><br><span class="line"><span class="keyword">if</span> (x==y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fa[y]=x,<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num[V][V];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n_=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=n_;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">num[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">det</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> sig=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!num[i][i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)</span><br><span class="line"><span class="keyword">if</span> (num[j][i])</span><br><span class="line">&#123;</span><br><span class="line">sig^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;++k) swap(num[i][k],num[j][k]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num[i][i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>,inv=quick_power(num[i][i],P<span class="number">-2</span>);j&lt;n;++j)</span><br><span class="line"><span class="keyword">if</span> (num[j][i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>,mul=<span class="number">1l</span>l*num[j][i]*inv%P;k&lt;n;++k)</span><br><span class="line">(num[j][k]+=P<span class="number">-1l</span>l*num[i][k]*mul%P)%=P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) ret=<span class="number">1l</span>l*ret*num[i][i]%P;</span><br><span class="line"><span class="keyword">return</span> sig&gt;<span class="number">0</span>?ret:P-ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;Kir;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x*(m+<span class="number">1</span>)+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;(++Kir.num[x][x])%=P,(++Kir.num[y][y])%=P,(Kir.num[x][y]+=P<span class="number">-1</span>)%=P,(Kir.num[y][x]+=P<span class="number">-1</span>)%=P;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"mirror.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"mirror.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;P),s=(n+<span class="number">1</span>)*(m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;s;++x) fa[x]=x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;!cir&amp;&amp;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,MAP[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;!cir&amp;&amp;j&lt;m;++j)</span><br><span class="line"><span class="keyword">if</span> (MAP[i][j]==<span class="string">'/'</span>) cir|=!merge(getid(i+<span class="number">1</span>,j),getid(i,j+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MAP[i][j]==<span class="string">'\\'</span>) cir|=!merge(getid(i,j),getid(i+<span class="number">1</span>,j+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cir) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;s;++x) lab[x]=<span class="number">-1</span>;</span><br><span class="line">idx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,x;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;++j)</span><br><span class="line"><span class="keyword">if</span> ((i^j^<span class="number">1</span>)&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">x=getid(i,j);</span><br><span class="line"><span class="keyword">if</span> (getfather(x)==x) lab[x]=idx++;</span><br><span class="line">&#125;</span><br><span class="line">Kir.init(idx);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line"><span class="keyword">if</span> (MAP[i][j]==<span class="string">'*'</span>)</span><br><span class="line"><span class="keyword">if</span> ((i^j^<span class="number">1</span>)&amp;<span class="number">1</span>) addedge(lab[fa[getid(i,j)]],lab[fa[getid(i+<span class="number">1</span>,j+<span class="number">1</span>)]]);</span><br><span class="line"><span class="keyword">else</span> addedge(lab[fa[getid(i+<span class="number">1</span>,j)]],lab[fa[getid(i,j+<span class="number">1</span>)]]);</span><br><span class="line">--Kir.n,ans=Kir.det();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;s;++x) lab[x]=<span class="number">-1</span>;</span><br><span class="line">idx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,x;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;++j)</span><br><span class="line"><span class="keyword">if</span> ((i^j)&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">x=getid(i,j);</span><br><span class="line"><span class="keyword">if</span> (getfather(x)==x) lab[x]=idx++;</span><br><span class="line">&#125;</span><br><span class="line">Kir.init(idx);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line"><span class="keyword">if</span> (MAP[i][j]==<span class="string">'*'</span>)</span><br><span class="line"><span class="keyword">if</span> ((i^j)&amp;<span class="number">1</span>) addedge(lab[fa[getid(i,j)]],lab[fa[getid(i+<span class="number">1</span>,j+<span class="number">1</span>)]]);</span><br><span class="line"><span class="keyword">else</span> addedge(lab[fa[getid(i+<span class="number">1</span>,j)]],lab[fa[getid(i,j+<span class="number">1</span>)]]);</span><br><span class="line">--Kir.n,(ans+=Kir.det())%=P,<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;一个 $n\times m$ 个格子的网格图，有些格子上有双面的镜子，有些格子上没有。镜子都是呈对角线放置（ &lt;code&gt;/&lt;/code&gt; 或 &lt;code&gt;\&lt;/code&gt; ）。&lt;br&gt;现在你要在所有没有镜子的格子上摆放镜子，使得最后网格图满足下面两个条件：&lt;br&gt;$\bullet$ 从网格图边界上的任意一条边垂直向内射入光线，光线一定会从一条相邻边射出网格图。&lt;br&gt;$\bullet$ 对于网格图的中的任意一条边，都存在一种从边界处一条边垂直向内射入光线的方法，使得这条边被光线穿过。&lt;br&gt;求满足条件的摆放镜子的方案数。答案对 $P$ 取模。&lt;/p&gt;
&lt;p&gt;$1\leq n,m\leq100,3\leq P\leq10^9+7,P\in\mathbb{P}$&lt;br&gt;空白格子个数 $K$ 不超过 $200$。&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="矩阵" scheme="http://yoursite.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="计数类问题" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="并查集" scheme="http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="生成树" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="Codeforces" scheme="http://yoursite.com/tags/Codeforces/"/>
    
      <category term="矩阵树定理" scheme="http://yoursite.com/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CodeChef PARADE</title>
    <link href="http://yoursite.com/2018/04/16/codechef-PARADE/"/>
    <id>http://yoursite.com/2018/04/16/codechef-PARADE/</id>
    <published>2018-04-16T03:17:02.000Z</published>
    <updated>2018-05-24T14:36:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一张$n$个点$m$条边的有向带边权图。<br>现在要选择一些至少经过一条边的路径（不一定是简单路径），花费的代价如下：<br>$\bullet$ 经过的所有边的长度之和，一条边被一条或多条路径经过多次，费用需要计算多次。<br>$\bullet$ 如果一条路径起点和终点不一样，则多花费$C$的代价。<br>$\bullet$ 如果一个点没有被任何路径经过，则多花费$C$的代价。<br>$q$次询问，每次给出$C$，最小化总花费。</p><p>$2\leq n\leq 250,1\leq m\leq3\times10^4,1\leq q\leq 10^4$<br>保证给定的图没有自环，但是可能会有重边。<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>多条路径可能会出现重复，这个不利于我们的计算。考虑人为地将经过的每一个点划分到某一条路径上，这样我们每一条路径都有若干“必须经过的点”。可以发现，在这些点之间肯定是走最短路最优。<br>因此考虑对原图求一次多源最短路，然后建一个新的图，两点$(x,y)$之间连的有向边权值是原图$x$到$y$的最短路。<br>根据上面所说，在最优情况下，新图中若干条不相交的路径，就可以对应于原图中的若干条合法路径。<br>既然现在我们要求不相交了，问题就好做了很多。考虑拆点网络流。$S\rightarrow x$、$x’\rightarrow T$连容量为$1$费用为$0$的边，$x\rightarrow y’$连容量为$1$费用为$dis_{x,y}$的边，跑最小费用流。<br>现在考虑加上$C$这个代价，可以发现，当增广的流量为$flow$的时候，我们的代价就是$(n-flow)C$：如果选择的某一条路径没有成环，那么经过的边数就是$flow$，点数就是$flow+1$，但是还要付出不成环的代价，也就是$(n-flow)C$；如果成环，那么经过的边数和点数都是$flow$，代价依然是$(n-flow)C$。<br>那么对于单次询问$C$，我们可以直接每次单路增广，取最后一次增广费用$&lt;C$的总费用作为答案。<br>不过现在是多次询问，我们不妨预处理每次单路增广的费用增量。由最小费用流的性质，这个值一定是单调不下降的，因此回答询问直接二分找到合适的位置就可以回答询问了。<br>时间复杂度$O\left(\mathrm{Maxflow}(n,n^2)+q\log n+n^3\right)$。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">30</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line"><span class="keyword">for</span> (;x;x/=<span class="number">10</span>) buf[++buf[<span class="number">0</span>]]=x%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (!buf[<span class="number">0</span>]) buf[++buf[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;buf[<span class="number">0</span>];<span class="built_in">putchar</span>(<span class="string">'0'</span>+buf[buf[<span class="number">0</span>]--]));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=INT_MAX&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">255</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> sum[N],cst[N];</span><br><span class="line"><span class="keyword">int</span> dis[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,q,flow;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> network</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V=N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> E=N*N+(N&lt;&lt;<span class="number">1</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> tov[E],nxt[E],f[E],v[E],c[E],r[E];</span><br><span class="line"><span class="keyword">int</span> last[V],dist[V],fp[V],fe[V];</span><br><span class="line"><span class="keyword">bool</span> exist[V];</span><br><span class="line"><span class="keyword">int</span> s,t,tot,cost;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> full,<span class="keyword">int</span> cst,<span class="keyword">int</span> rev)</span></span>&#123;tov[++tot]=y,f[tot]=full,c[tot]=cst,r[tot]=tot+rev,nxt[tot]=last[x],last[x]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> full,<span class="keyword">int</span> cst)</span></span>&#123;insert(x,y,full,cst,<span class="number">1</span>),insert(y,x,<span class="number">0</span>,-cst,<span class="number">-1</span>);&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=s;x&lt;=t;++x) dist[x]=INF;</span><br><span class="line">dist[s]=<span class="number">0</span>,q.push(s),exist[s]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x;!q.empty();)</span><br><span class="line">&#123;</span><br><span class="line">x=q.front(),q.pop(),exist[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=last[x],y;i;i=nxt[i])</span><br><span class="line"><span class="keyword">if</span> (dist[y=tov[i]]&gt;dist[x]+c[i]&amp;&amp;f[i]-v[i])</span><br><span class="line">&#123;</span><br><span class="line">dist[y]=dist[x]+c[i],fp[y]=x,fe[y]=i;</span><br><span class="line"><span class="keyword">if</span> (!exist[y]) q.push(y),exist[y]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dist[t]==INF) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=t,i;x!=s;x=fp[x]) cost+=c[i=fe[x]],++v[i],--v[r[i]];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cst[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (flow=<span class="number">1</span>;flow&lt;=n;++flow)</span><br><span class="line">&#123;</span><br><span class="line">cost=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (spfa()) sum[flow]=sum[flow<span class="number">-1</span>]+(cst[flow]=cost);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">--flow;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s=<span class="number">0</span>,t=n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x) addedge(s,(x&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>),addedge(x&lt;&lt;<span class="number">1</span>,t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=n;++y)</span><br><span class="line"><span class="keyword">if</span> (x!=y) addedge((x&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>,y&lt;&lt;<span class="number">1</span>,<span class="number">1</span>,dis[x][y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;++k)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span> (i!=k)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line"><span class="keyword">if</span> (i!=j&amp;&amp;j!=k)</span><br><span class="line">dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"parade.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"parade.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">n=read(),m=read(),q=read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=n;++y) dis[x][y]=INF;</span><br><span class="line">dis[x][x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=m;++i) x=read(),y=read(),z=read(),dis[x][y]=min(dis[x][y],z);</span><br><span class="line"><span class="keyword">for</span> (floyd(),network::build(),network::calc();q--;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> c=read(),ret=<span class="number">0</span>,l=<span class="number">0</span>,r=flow;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid;l&lt;=r;)</span><br><span class="line">&#123;</span><br><span class="line">mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (cst[mid]&lt;c) l=(ret=mid)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">write(sum[ret]+(n-ret)*c),<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一张$n$个点$m$条边的有向带边权图。&lt;br&gt;现在要选择一些至少经过一条边的路径（不一定是简单路径），花费的代价如下：&lt;br&gt;$\bullet$ 经过的所有边的长度之和，一条边被一条或多条路径经过多次，费用需要计算多次。&lt;br&gt;$\bullet$ 如果一条路径起点和终点不一样，则多花费$C$的代价。&lt;br&gt;$\bullet$ 如果一个点没有被任何路径经过，则多花费$C$的代价。&lt;br&gt;$q$次询问，每次给出$C$，最小化总花费。&lt;/p&gt;
&lt;p&gt;$2\leq n\leq 250,1\leq m\leq3\times10^4,1\leq q\leq 10^4$&lt;br&gt;保证给定的图没有自环，但是可能会有重边。&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="CodeChef" scheme="http://yoursite.com/tags/CodeChef/"/>
    
      <category term="二分法" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
      <category term="网络流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>AGC021-F Trinity</title>
    <link href="http://yoursite.com/2018/04/04/agc021-f/"/>
    <id>http://yoursite.com/2018/04/04/agc021-f/</id>
    <published>2018-04-04T12:41:40.000Z</published>
    <updated>2018-04-04T13:01:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有一个$n\times m$的网格，有的格子被涂成了黑色，有的被涂成了白色。<br>定义三个数组$\{A_n\},\{B_m\},\{C_m\}$，分别表示第$i$行第一个黑格子的列编号，第$i$列第一个/最后一个黑格子的行编号。特殊地，如果这一行/列没有黑格子，值就分别是$m+1,n+1$和$0$。<br>求所有可能的数组三元组$(A,B,C)$的个数。<br>答案对$998244353$取模。</p><p>$1\leq n\leq8\times10^3,1\leq m\leq200$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>令$f_{n,m}$表示$n\times m$的网格，每一行都有黑色格子，能形成的不同的三元组个数。<br>行的约束比列的约束要少，考虑按列转移，每次加入一列，然后加入所有第一个黑格子在这一列的行，假设有$k$个，那么就换转移到$f_{n+k,m+1}$。<br>如果$k=0$，当新的一列没有黑格子的时候转移系数是$1$，否则就是$1\leq i\leq j\leq n$的$(i,j)$的对数，即${n+1\choose 2}$。<br>如果$k&gt;0$，那么就会插入$k$个新的行，但是最小值最大值可能是在之前已经加入过的行里面。这个很简单，我们假定最小值向前移动一位另成一行，最大值向后移动一位另成一行，然后新增的行数$+2$，可以发现这样是等价的，因为我们只要将极值与另一个新增行连着当成新增行为极值，否则当成连着的那一行为极值。于是转移的系数是${n+k+2\choose k+2}$。<br>这样直接dp就是$O(n^2m)$的了。优化的话将组合数展开，写成卷积的形式，使用NTT加速就好了。<br>时间复杂度是$O(mn\log n)$。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L=<span class="number">16384</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fact[L],invf[L],f[L],g[L],h[L],t[L],trs[L];</span><br><span class="line"><span class="keyword">int</span> omega[L+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,len,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%P) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) ret=<span class="number">1l</span>l*ret*x%P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;L;++i) fact[i]=<span class="number">1l</span>l*fact[i<span class="number">-1</span>]*i%P;</span><br><span class="line">invf[L<span class="number">-1</span>]=quick_power(fact[L<span class="number">-1</span>],P<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=L<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i) invf[i<span class="number">-1</span>]=<span class="number">1l</span>l*invf[i]*i%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;<span class="keyword">return</span> n&gt;=m?<span class="number">1l</span>l*fact[n]*invf[m]%P*invf[n-m]%P:<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT_pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (len=<span class="number">1</span>;len&lt;=n&lt;&lt;<span class="number">1</span>;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,ret;i&lt;len;++i)</span><br><span class="line">&#123;</span><br><span class="line">ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=i,j=<span class="number">1</span>;j&lt;len;j&lt;&lt;=<span class="number">1</span>,x&gt;&gt;=<span class="number">1</span>) ret=(ret&lt;&lt;<span class="number">1</span>)|(x&amp;<span class="number">1</span>);</span><br><span class="line">trs[i]=ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> g=quick_power(G,(P<span class="number">-1</span>)/len);omega[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;++i) omega[i]=<span class="number">1l</span>l*omega[i<span class="number">-1</span>]*g%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) t[trs[i]]=a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> l=<span class="number">2</span>;l&lt;=len;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> h=l&gt;&gt;<span class="number">1</span>,j=<span class="number">0</span>,wn=omega[sig&gt;<span class="number">0</span>?len/l:len-len/l];j&lt;len;j+=l)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>,w=<span class="number">1</span>;i&lt;h;++i,w=<span class="number">1l</span>l*w*wn%P)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> u=t[i+j],v=<span class="number">1l</span>l*t[i+j+h]*w%P;</span><br><span class="line">t[i+j]=(u+v)%P,t[i+j+h]=(u-v+P)%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=t[i];</span><br><span class="line"><span class="keyword">if</span> (sig&lt;<span class="number">0</span>) <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>,inv=quick_power(len,P<span class="number">-2</span>);i&lt;len;++i) a[i]=<span class="number">1l</span>l*a[i]*inv%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"trinity.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"trinity.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m),pre(),NTT_pre();</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) g[i]=invf[i+<span class="number">2</span>];</span><br><span class="line">DFT(g,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;++j) h[j]=<span class="number">1l</span>l*f[j]*invf[j]%P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=n+<span class="number">1</span>;j&lt;len;++j) h[j]=<span class="number">0</span>;</span><br><span class="line">DFT(h,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;++j) h[j]=<span class="number">1l</span>l*h[j]*g[j]%P;</span><br><span class="line">DFT(h,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;++j) f[j]=(<span class="number">1l</span>l*fact[j+<span class="number">2</span>]*h[j]%P+<span class="number">1l</span>l*(C(j+<span class="number">1</span>,<span class="number">2</span>)+<span class="number">1</span>)*f[j]%P)%P;</span><br><span class="line">&#125;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) (ans+=<span class="number">1l</span>l*C(n,i)*f[i]%P)%=P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;有一个$n\times m$的网格，有的格子被涂成了黑色，有的被涂成了白色。&lt;br&gt;定义三个数组$\{A_n\},\{B_m\},\{C_m\}$，分别表示第$i$行第一个黑格子的列编号，第$i$列第一个/最后一个黑格子的行编号。特殊地，如果这一行/列没有黑格子，值就分别是$m+1,n+1$和$0$。&lt;br&gt;求所有可能的数组三元组$(A,B,C)$的个数。&lt;br&gt;答案对$998244353$取模。&lt;/p&gt;
&lt;p&gt;$1\leq n\leq8\times10^3,1\leq m\leq200$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="AtCoder" scheme="http://yoursite.com/tags/AtCoder/"/>
    
      <category term="计数类问题" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="普通动态规划" scheme="http://yoursite.com/tags/%E6%99%AE%E9%80%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="组合数" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="FFT/NTT/FWT" scheme="http://yoursite.com/tags/FFT-NTT-FWT/"/>
    
  </entry>
  
  <entry>
    <title>Delannoy Number</title>
    <link href="http://yoursite.com/2018/03/29/Delannoy-number/"/>
    <id>http://yoursite.com/2018/03/29/Delannoy-number/</id>
    <published>2018-03-29T07:46:35.000Z</published>
    <updated>2018-03-29T08:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个挺有趣的数，做题遇到了，在此mark一下。</p><a id="more"></a><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>定义$D(n,m)$表示在一个$n\times m$的网格图上，每次向右/左/右上走，从$(0,0)$到达$(n,m)$的方案数。</p><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>首先有一个很显然的式子就是$$D(n,m)=\sum_{k=0}^{\min(n,m)}{n+m-k\choose n}{n\choose k}$$<br>然后还有一个十分优美的对称的式子是$$D(n,m)=\sum_{k=0}^{\min(n,m)}{n\choose k}{m\choose k}2^k$$</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>我们假定所有的右上都是由$\rightarrow\uparrow$走出来的。<br>考虑只有向右和向上两种走法，假设其中有$i$个相邻的$\rightarrow\uparrow$的组合（注意必须$\rightarrow$在前），那么就有${n\choose i}{m\choose i}$种$\rightarrow$与$\uparrow$匹配的可能性。<br>注意到一旦我们确定了匹配的方案，在开头结尾以及$\rightarrow\uparrow$组合之间的空隙里，我们只能是填上一系列$\uparrow$加上一系列$\rightarrow$，不然就会产生新的$\rightarrow\uparrow$组合，也就说剩下的填法是唯一确定的。<br>然后这$i$个$\rightarrow\uparrow$组合，我们可以选择是否将其变成右上的走法，于是就会产生$2^i$的系数。<br>因此最终的方案数就是$$D(n,m)=\sum_{k=0}^{\min(n,m)}{n\choose k}{m\choose k}2^k$$</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://nanti.jisuanke.com/t/15970" target="_blank" rel="noopener">2017计蒜之道复赛E - 商汤智能机器人</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://en.wikipedia.org/wiki/Delannoy_number" target="_blank" rel="noopener">Wikipedia - Delannoy number</a><br><a href="https://math.stackexchange.com/questions/129719/combinatorial-interpretation-of-delannoy-numbers-formula" target="_blank" rel="noopener">MATHEMATICS</a><br><a href="http://oeis.org/A008288" target="_blank" rel="noopener">OEIS - A008288</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一个挺有趣的数，做题遇到了，在此mark一下。&lt;/p&gt;
    
    </summary>
    
      <category term="学习小记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="计数类问题" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="组合数" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>HackerRank - Week of Code 34 - Magic Cards</title>
    <link href="http://yoursite.com/2018/03/28/hackerrank-magic-cards/"/>
    <id>http://yoursite.com/2018/03/28/hackerrank-magic-cards/</id>
    <published>2018-03-28T13:11:04.000Z</published>
    <updated>2018-03-28T13:27:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>桌面上有$n$张牌，每张牌上都写上了$1$到$m$的所有正整数各一次，其中有的数字写在牌的正面，有的在反面。<br>有$q$次询问，每次询问一个区间$[l,r]$的所有牌，每张牌可以任意决定正面还是反面朝上，问朝上的牌中所有出现过至少一次的数的平方和的最大值是多少。</p><p>$1\leq n\times m,q\leq10^6$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>挺有趣的一道题目，一开始看上去不怎么可做。发现了性质之后就简单很多了。</p><p>可以发现只要区间内牌的数目超过了$L=\lceil\log_2 m\rceil$，就一定可以让所有的数字都出现。<br>证明很简单，假设我们现在要大小为$x$的数字集合全部出现，由于一张牌上写了所有的数字，因此正面朝上或者反面朝上一定有一种情况出现数字集合与目标集合的交集大小$\geq\lceil\frac x2\rceil$，因此目标集合大小至少减半。<br>接下来就很简单了，考虑预处理所有长度为$L$的区间的答案，我们直接算出每个数字在各个牌的正反情况存成一个$L$位二进制$s$，然后枚举出现情况的二进制$S$，将总和减去$s=\lnot S$的数字平方和更新就好了。<br>时间复杂度$O(nm\log m+q)$。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line"><span class="keyword">for</span> (;x;x/=<span class="number">10</span>) buf[++buf[<span class="number">0</span>]]=x%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (!buf[<span class="number">0</span>]) buf[++buf[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;buf[<span class="number">0</span>];<span class="built_in">putchar</span>(<span class="string">'0'</span>+buf[buf[<span class="number">0</span>]--]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL=<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cards[N];</span><br><span class="line">LL ans[N][MAXL];</span><br><span class="line"><span class="keyword">int</span> state[M];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line">LL bin[M];</span><br><span class="line"><span class="keyword">int</span> n,m,q,L;</span><br><span class="line">LL all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L=(<span class="keyword">int</span>)<span class="built_in">ceil</span>(<span class="built_in">log</span>(m)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=L;++l)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i+l<span class="number">-1</span>&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;<span class="number">1</span>&lt;&lt;l;++s) bin[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) state[j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=l;++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x:cards[i+j<span class="number">-1</span>])</span><br><span class="line">state[x]|=<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) bin[(~state[j])&amp;((<span class="number">1</span>&lt;&lt;l)<span class="number">-1</span>)]+=<span class="number">1l</span>l*j*j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) bin[(~state[j])&amp;((<span class="number">1</span>&lt;&lt;l)<span class="number">-1</span>)]-=<span class="number">1l</span>l*j*j,state[j]&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x:cards[i+l<span class="number">-1</span>]) state[x]|=<span class="number">1</span>&lt;&lt;l<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) bin[(~state[j])&amp;((<span class="number">1</span>&lt;&lt;l)<span class="number">-1</span>)]+=<span class="number">1l</span>l*j*j;</span><br><span class="line">&#125;</span><br><span class="line">LL ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;<span class="number">1</span>&lt;&lt;l;++s) ret=max(ret,all-bin[s]);</span><br><span class="line">ans[i][l<span class="number">-1</span>]=ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"magiccards.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"magiccards.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">n=read(),m=read(),q=read(),all=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) all+=<span class="number">1l</span>l*i*i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">cnt[i]=read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt[i];++j) cards[i].push_back(read());</span><br><span class="line">&#125;</span><br><span class="line">pre();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,l,r;i&lt;=q;++i,<span class="built_in">putchar</span>(<span class="string">'\n'</span>))</span><br><span class="line">&#123;</span><br><span class="line">l=read(),r=read();</span><br><span class="line"><span class="keyword">if</span> (r-l+<span class="number">1</span>&gt;L) write(all);</span><br><span class="line"><span class="keyword">else</span> write(ans[l][r-l]);</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;桌面上有$n$张牌，每张牌上都写上了$1$到$m$的所有正整数各一次，其中有的数字写在牌的正面，有的在反面。&lt;br&gt;有$q$次询问，每次询问一个区间$[l,r]$的所有牌，每张牌可以任意决定正面还是反面朝上，问朝上的牌中所有出现过至少一次的数的平方和的最大值是多少。&lt;/p&gt;
&lt;p&gt;$1\leq n\times m,q\leq10^6$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="bitmasks" scheme="http://yoursite.com/tags/bitmasks/"/>
    
      <category term="预处理" scheme="http://yoursite.com/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
      <category term="HackerRank" scheme="http://yoursite.com/tags/HackerRank/"/>
    
  </entry>
  
  <entry>
    <title>hihoCoder Challenge 31 D - K-Beautiful Tree</title>
    <link href="http://yoursite.com/2018/03/28/hihocoder-challenge31-d/"/>
    <id>http://yoursite.com/2018/03/28/hihocoder-challenge31-d/</id>
    <published>2018-03-28T08:12:01.000Z</published>
    <updated>2018-03-28T13:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有$n$个节点，第$i$个点有颜色$c_i$。<br>定义一棵无根树$T$是$k-$美丽的，当且仅当$T$不存在大于$k$个点的同色联通子图。<br>现在给定$n,k$以及$\{c_n\}$。请计算所有不同的$k-$美丽带标号无根树的数目。<br>答案对$10^9+7$取模。</p><p>$1\leq k\leq n\leq300$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>由于我计数水平太低，这题对着题解断断续续搞了好久qwq</p><p>首先考虑$k=1$怎么做，即要求所有的同色点不能相邻。<br>考虑容斥，假设有$x$对同色点相邻容斥系数就是$(-1)^x$。<br>计算的话就是考虑将点集分成若干个同色连通块再乘上容斥系数。计算分块后的无根树数目，有一个结论就是假设我们分成了$m$个块，大小满足$\sum_{i=1}^ma_i=n$，那么无根树数目就是$n^{m-2}\prod_{i=1}^ma_i$，使用Prüfer序就可以证明。<br>所以我们只需要dp分组的方案，在dp中带上容斥系数以及$\prod a_i$并记录分组数目就好了。<br>至于$k&gt;1$的情况，可以发现，假如我们在计算之前先把点集分成一些大小不超过$k$的同色联通块，然后将它们视做单个点，这个容斥依然是正确的（一种合法方案一定由若干个不相邻的极大同色连通块组成）。于是我们相当于要在dp内再套一个分组，这个只需要在前面再跑一个类似的分组dp就好了。<br>要注意的一点是虽然我们将计算前分好的同色连通块视为一个点做容斥，但是在计算无根树方案的时候节点个数应当是真实的节点个数。<br>最后时间复杂度是$O(n^3)$的。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>两层分组嵌套，关系不要写错了qwq<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">305</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C[N][N],f[N][N],g[N][N],pw[N][N];</span><br><span class="line"><span class="keyword">int</span> dp[N],F[N],cnt[N];</span><br><span class="line"><span class="keyword">int</span> n,K,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span></span>&#123;(x+=y)%=P;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sig</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;<span class="number">1</span>?P<span class="number">-1</span>:<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%P) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) ret=<span class="number">1l</span>l*ret*x%P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j) C[i][j]=(C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j])%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">pw[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) pw[i][j]=<span class="number">1l</span>l*pw[i][j<span class="number">-1</span>]*i%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=K&amp;&amp;k&lt;=i;++k)</span><br><span class="line">update(f[i][j],<span class="number">1l</span>l*f[i-k][j<span class="number">-1</span>]*C[i<span class="number">-1</span>][k<span class="number">-1</span>]%P*(k==<span class="number">1</span>?<span class="number">1</span>:pw[k][k<span class="number">-2</span>])%P*k%P);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">F[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j) update(F[i],<span class="number">1l</span>l*f[i][j]*sig(j<span class="number">-1</span>)%P*(j&gt;=<span class="number">2</span>?pw[i][j<span class="number">-2</span>]:(j?quick_power(i,P<span class="number">-2</span>):<span class="number">1</span>))%P);</span><br><span class="line">&#125;</span><br><span class="line">g[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=i;++k)</span><br><span class="line">update(g[i][j],<span class="number">1l</span>l*g[i-k][j<span class="number">-1</span>]*C[i<span class="number">-1</span>][k<span class="number">-1</span>]%P*F[k]%P*k%P);</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,siz=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span> (cnt[i])</span><br><span class="line">&#123;</span><br><span class="line">siz+=cnt[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=siz;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=<span class="number">1l</span>l*dp[j]*g[cnt[i]][<span class="number">0</span>]%P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=cnt[i]&amp;&amp;k&lt;=j;++k) update(dp[j],<span class="number">1l</span>l*dp[j-k]*g[cnt[i]][k]%P);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=<span class="number">1l</span>l*dp[<span class="number">1</span>]*quick_power(n,P<span class="number">-2</span>)%P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) update(ans,<span class="number">1l</span>l*dp[i]*pw[n][i<span class="number">-2</span>]%P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"kbtree.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"kbtree.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;K);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),++cnt[x];</span><br><span class="line">pre(),calc(),<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;有$n$个节点，第$i$个点有颜色$c_i$。&lt;br&gt;定义一棵无根树$T$是$k-$美丽的，当且仅当$T$不存在大于$k$个点的同色联通子图。&lt;br&gt;现在给定$n,k$以及$\{c_n\}$。请计算所有不同的$k-$美丽带标号无根树的数目。&lt;br&gt;答案对$10^9+7$取模。&lt;/p&gt;
&lt;p&gt;$1\leq k\leq n\leq300$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="计数类问题" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="普通动态规划" scheme="http://yoursite.com/tags/%E6%99%AE%E9%80%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="组合数" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="容斥原理" scheme="http://yoursite.com/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
      <category term="hihoCoder" scheme="http://yoursite.com/tags/hihoCoder/"/>
    
      <category term="Prufer序" scheme="http://yoursite.com/tags/Prufer%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>AGC021-E Ball Eat Chameleons</title>
    <link href="http://yoursite.com/2018/03/14/agc021-e/"/>
    <id>http://yoursite.com/2018/03/14/agc021-e/</id>
    <published>2018-03-14T08:55:08.000Z</published>
    <updated>2018-03-14T09:19:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>你有$n$只吃球的变色龙，每一只变色龙一开始都是蓝色的。<br>一只蓝色变色龙变成红色当且仅当其吃下的红色球数目<strong>严格大于</strong>蓝色球的数目。同理，一只红色变色龙变成蓝色当且仅当其吃下的蓝色球数目<strong>严格大于</strong>红色球的数目。<br>你要投喂$K$次，每一次你挑一种颜色的球，然后丢到笼子里给任意一个变色龙吃。<br>已知最后变色龙都变成了红色，求有多少种不同的颜色序列可能造成这一种情况（判重时并不考虑具体谁吃了，只考虑颜色）。</p><p>$1\leq n,K\leq5\times10^5$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>显然颜色序列合法当且仅当我们能将其划分成$n$个子序列，使得每一个子序列要么满足红球数目严格大于蓝球，要么满足红球数目与蓝球数目相等且最后一个球是蓝球。<br>令红球数目为$R$，蓝球数目为$B$。我们枚举红球数目，考虑数形结合，将红篮球的状态表示成二维平面上的点，要从$(0,0)$走正方向到某个位置。分下面两种情况讨论：</p><ul><li>$R=B$，那么最后一个球一定是蓝色的。给定一个颜色序列，我们可以这样贪心匹配：先弄出$n$对红蓝两球，然后剩下的全部分给最后一对。那么其实就是从$(0,0)$走到$(R,B-1)$，并且不能经过$y-x\geq R-n+1$的点。</li><li>$R&gt;B$，依然贪心匹配：先弄出$n-(R-B)$对红蓝两球，然后剩下的全部分给任意一个最终红球大于蓝球的序列。其实就是从$(0,0)$走到$(R,B)$，并且不能经过$y-x\geq R-n+1$的点。</li></ul><p>直接用卡特兰数计算就好了。<br>时间复杂度$O(K)$。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L=<span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fact[L+<span class="number">5</span>],invf[L+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n,K,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%P) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) ret=<span class="number">1l</span>l*ret*x%P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=L;++i) fact[i]=<span class="number">1l</span>l*fact[i<span class="number">-1</span>]*i%P;</span><br><span class="line">invf[L]=quick_power(fact[L],P<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=L;i&gt;=<span class="number">1</span>;--i) invf[i<span class="number">-1</span>]=<span class="number">1l</span>l*invf[i]*i%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;<span class="keyword">return</span> n&gt;=m?<span class="number">1l</span>l*fact[n]*invf[m]%P*invf[n-m]%P:<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m-n&gt;=t||t&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (C(n+m,m)-C(n+m,n+t)+P)%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"chameleons.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"chameleons.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">pre(),<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;K),ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> R=K,B;R&gt;=K-R&amp;&amp;R&gt;=<span class="number">0</span>;--R)</span><br><span class="line">&#123;</span><br><span class="line">B=K-R;</span><br><span class="line"><span class="keyword">if</span> (R==B) (ans+=calc(R,B<span class="number">-1</span>,R-n+<span class="number">1</span>))%=P;</span><br><span class="line"><span class="keyword">else</span> (ans+=calc(R,B,R-n+<span class="number">1</span>))%=P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;你有$n$只吃球的变色龙，每一只变色龙一开始都是蓝色的。&lt;br&gt;一只蓝色变色龙变成红色当且仅当其吃下的红色球数目&lt;strong&gt;严格大于&lt;/strong&gt;蓝色球的数目。同理，一只红色变色龙变成蓝色当且仅当其吃下的蓝色球数目&lt;strong&gt;严格大于&lt;/strong&gt;红色球的数目。&lt;br&gt;你要投喂$K$次，每一次你挑一种颜色的球，然后丢到笼子里给任意一个变色龙吃。&lt;br&gt;已知最后变色龙都变成了红色，求有多少种不同的颜色序列可能造成这一种情况（判重时并不考虑具体谁吃了，只考虑颜色）。&lt;/p&gt;
&lt;p&gt;$1\leq n,K\leq5\times10^5$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="AtCoder" scheme="http://yoursite.com/tags/AtCoder/"/>
    
      <category term="计数类问题" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="组合数" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="卡特兰数" scheme="http://yoursite.com/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>CodeChef BINOMSUM</title>
    <link href="http://yoursite.com/2018/03/12/codechef-BINOMSUM/"/>
    <id>http://yoursite.com/2018/03/12/codechef-BINOMSUM/</id>
    <published>2018-03-12T13:45:45.000Z</published>
    <updated>2018-03-12T23:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>假定有$T$天，每天有$K$个小时，你要安排每一天的日程。<br>第$i$天有$D+i−1$道菜，第一个小时你必须选择$L$道菜吃，接下来每个小时你可以选择吃一道菜或者选择$A$个活动中的一个参加，不能连续两个小时吃菜（但是一天的最后一个小时和下一天的第一个小时连着吃是可以的）。<br>$K,A$是事先给定的值。有$Q$次询问，每次给出$L,D,T$，问这$T$天每一天安排的方案数<strong>之和</strong>。<br>答案对$P$（事先给定）取模。</p><p>$2\leq K\leq 10^5,1\leq Q\leq 500,1\leq L\leq D\leq D+T-1\leq10^7,10^8+7\leq P\leq10^9+7,P\in\mathbb P$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>首先根据题意很快就可以写出方案数的式子：<br>$$\sum_{i=1}^T{D+i+1\choose L}\sum_{j=0}^{K-1}\left(D+i-1\right)^jA^{K-j-1}{K-j-1\choose j}$$可以发现第二个$\Sigma$后面的是一个度数为$K/2$的多项式，但是我们后面懒得管这么多直接当$K$。<br>然后是一波操作：考虑将后面的多项式写成阶乘多项式的形式：<br>$$F(x)=\sum_{i=0}^{K-1}a_i\prod_{j=1}^i(x+j)$$也就是答案是<br>$$\sum_{i=D}^{D+T-1}{i\choose L}F(i)$$然后推一推<br>$$<br>\begin{align}<br>\sum_{i=D}^{D+T-1}{i\choose L}F(i)&amp;=\sum_{i=D}^{D+T-1}{i\choose L}\sum_{j=0}^{K-1}a_j\prod_{k=1}^j(i+k)\<br>&amp;=\sum_{i=D}^{D+T-1}{i\choose L}\sum_{j=0}^{K-1}a_j\frac{(i+j)!}{i!}\<br>&amp;=\sum_{i=0}^{K-1}a_i\sum_{j=D}^{D+T-1}{j\choose L}\frac{(i+j)!}{j!}\<br>&amp;=\frac{\sum_{i=0}^{K-1}a_i\sum_{j=D}^{D+T-1}\frac{(i+j)!}{(j-L)!}}{L!}\<br>&amp;=\frac{\sum_{i=0}^{K-1}a_i(i+L)!\sum_{j=D}^{D+T-1}{i+j\choose i+L}}{L!}\<br>&amp;=\frac{\sum_{i=0}^{K-1}a_i(i+L)!\left({D+T+i\choose L+i+1}-{D+i\choose L+i+1}\right)}{L!}<br>\end{align}<br>$$如果我们知道了$\{a_n\}$，单次询问就可以直接$O(K)$计算。<br>然后我们来算这个$\{a_n\}$。显然有$F(x)=\sum_{i=0}^{K-1}a_i\cdot i!{x+i\choose i}$。<br>我们考虑求出$F(x)$在$-1,-2,…,-K$处的点值，目的是利用里面的负号凑出二项式反演的形式：<br>$$<br>\begin{align}<br>F(-n-1)&amp;=\sum_{i=0}^{K-1}a_i\cdot i!{-n-1+i\choose i}\<br>&amp;=\sum_{i=0}^na_i\cdot i!(-1)^i{n\choose i}<br>\end{align}<br>$$<br>反演得到$$a_n\cdot n!=\sum_{i=0}^{K-1}(-1)^i{n\choose i}F(-i-1)$$也就是说$$a_n=\sum_{i=0}^n\frac{(-1)^iF(-i-1)}{i!}\frac1{(n-i)!}$$直接FFT做卷积就好了。<br>至于这个$F(x)$怎么快速地求值，观察$F(x)$原本对应的式子可以发现，只要将组合数用杨辉三角拆开，就能得到递推式：$F_k(x)=AF_{k-1}(x)+xAF_{k-2}(x)$。用矩阵快速幂就好了。<br>时间复杂度$O(K\log K+QK+(D+T))$。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line"><span class="keyword">for</span> (;x;x/=<span class="number">10</span>) buf[++buf[<span class="number">0</span>]]=x%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (!buf[<span class="number">0</span>]) buf[++buf[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;buf[<span class="number">0</span>];<span class="built_in">putchar</span>(<span class="string">'0'</span>+buf[buf[<span class="number">0</span>]--]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">15000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L=<span class="number">262144</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fact[N+<span class="number">5</span>],invf[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> K,A_,P,T,q,len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%P) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) ret=<span class="number">1l</span>l*ret*x%P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sig</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;<span class="number">1</span>?P<span class="number">-1</span>:<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;<span class="keyword">return</span> n&gt;=m?<span class="number">1l</span>l*fact[n]*invf[m]%P*invf[n-m]%P:<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i) fact[i]=<span class="number">1l</span>l*fact[i<span class="number">-1</span>]*i%P;</span><br><span class="line">invf[N]=quick_power(fact[N],P<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=N;i&gt;=<span class="number">1</span>;--i) invf[i<span class="number">-1</span>]=<span class="number">1l</span>l*invf[i]*i%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> r,c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">matrix</span><span class="params">()</span></span>&#123;r=c=<span class="number">2</span>,num[<span class="number">0</span>][<span class="number">0</span>]=num[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>,num[<span class="number">0</span>][<span class="number">1</span>]=num[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> matrix <span class="keyword">operator</span>*(matrix <span class="keyword">const</span> mat)</span><br><span class="line">&#123;</span><br><span class="line">matrix ret;<span class="built_in">memset</span>(ret.num,<span class="number">0</span>,<span class="keyword">sizeof</span> ret.num);</span><br><span class="line">ret.r=r,ret.c=mat.c;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ret.r;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ret.c;++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;c;++k)</span><br><span class="line">(ret.num[i][j]+=<span class="number">1l</span>l*num[i][k]*mat.num[k][j]%P)%=P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;trans,fk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> matrix <span class="keyword">operator</span>^(matrix x,<span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">matrix ret=matrix();</span><br><span class="line"><span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=x*x) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) ret=ret*x;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Fk</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fk.r=<span class="number">1</span>,fk.c=<span class="number">2</span>,fk.num[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>,fk.num[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">trans.r=trans.c=<span class="number">2</span>,trans.num[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>,trans.num[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1l</span>l*x*A_%P,trans.num[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>,trans.num[<span class="number">1</span>][<span class="number">1</span>]=A_;</span><br><span class="line"><span class="keyword">return</span> (fk*(trans^K)).num[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Z</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">db x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Z</span><span class="params">(db x_=<span class="number">0.</span>,db y_=<span class="number">0.</span>)</span></span>&#123;x=x_,y=y_;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Z <span class="keyword">operator</span>+(Z <span class="keyword">const</span> z)<span class="keyword">const</span>&#123;<span class="keyword">return</span> Z(x+z.x,y+z.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> Z <span class="keyword">operator</span>-(Z <span class="keyword">const</span> z)<span class="keyword">const</span>&#123;<span class="keyword">return</span> Z(x-z.x,y-z.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> Z <span class="keyword">operator</span>*(Z <span class="keyword">const</span> z)<span class="keyword">const</span>&#123;<span class="keyword">return</span> Z(x*z.x-y*z.y,x*z.y+y*z.x);&#125;</span><br><span class="line"><span class="keyword">inline</span> Z <span class="keyword">operator</span>*(db <span class="keyword">const</span> k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> Z(x*k,y*k);&#125;</span><br><span class="line">&#125;omega[L+<span class="number">5</span>],A[<span class="number">2</span>][L],B[<span class="number">2</span>][L],cnt[<span class="number">4</span>][L],t[L];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[L],g[L],a[L];</span><br><span class="line"><span class="keyword">int</span> trs[L];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT_pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (len=<span class="number">1</span>;len&lt;(K&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,ret;i&lt;len;++i)</span><br><span class="line">&#123;</span><br><span class="line">ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=i,j=<span class="number">1</span>;j&lt;len;j&lt;&lt;=<span class="number">1</span>,x&gt;&gt;=<span class="number">1</span>) ret=(ret&lt;&lt;<span class="number">1</span>)|(x&amp;<span class="number">1</span>);</span><br><span class="line">trs[i]=ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;++i) omega[i]=Z(<span class="built_in">cos</span>(<span class="number">2.</span>*pi*i/len),<span class="built_in">sin</span>(<span class="number">2.</span>*pi*i/len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(Z *a,<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) t[trs[i]]=a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> l=<span class="number">2</span>;l&lt;=len;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">0</span>,h=l&gt;&gt;<span class="number">1</span>;j&lt;len;j+=l)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;++i)</span><br><span class="line">&#123;</span><br><span class="line">Z w=omega[sig&gt;<span class="number">0</span>?len/l*i:len-len/l*i],u=t[i+j],v=t[i+j+h]*w;</span><br><span class="line">t[i+j]=u+v,t[i+j+h]=u-v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=t[i];</span><br><span class="line"><span class="keyword">if</span> (sig&lt;<span class="number">0</span>) <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) a[i]=a[i]*(<span class="number">1.</span>/len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b,<span class="keyword">int</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) A[<span class="number">0</span>][i]=Z(a[i]/T,<span class="number">0</span>),A[<span class="number">1</span>][i]=Z(a[i]%T,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) B[<span class="number">0</span>][i]=Z(b[i]/T,<span class="number">0</span>),B[<span class="number">1</span>][i]=Z(b[i]%T,<span class="number">0</span>);</span><br><span class="line">DFT(A[<span class="number">0</span>],<span class="number">1</span>),DFT(A[<span class="number">1</span>],<span class="number">1</span>),DFT(B[<span class="number">0</span>],<span class="number">1</span>),DFT(B[<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) cnt[<span class="number">0</span>][i]=A[<span class="number">0</span>][i]*B[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) cnt[<span class="number">1</span>][i]=A[<span class="number">0</span>][i]*B[<span class="number">1</span>][i]+A[<span class="number">1</span>][i]*B[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) cnt[<span class="number">2</span>][i]=A[<span class="number">1</span>][i]*B[<span class="number">1</span>][i];</span><br><span class="line">DFT(cnt[<span class="number">0</span>],<span class="number">-1</span>),DFT(cnt[<span class="number">1</span>],<span class="number">-1</span>),DFT(cnt[<span class="number">2</span>],<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) c[i]=((LL)(cnt[<span class="number">0</span>][i].x+<span class="number">.5</span>)%P*T%P*T%P+(LL)(cnt[<span class="number">1</span>][i].x+<span class="number">.5</span>)%P*T%P+(LL)(cnt[<span class="number">2</span>][i].x+<span class="number">.5</span>)%P)%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pre();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;++i) f[i]=<span class="number">1l</span>l*Fk(P-i<span class="number">-1</span>)*invf[i]%P*sig(i)%P,g[i]=invf[i];</span><br><span class="line">FFT_pre(),mult(f,g,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"binomsum.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"binomsum.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">for</span> (K=read(),A_=read(),P=read(),T=trunc(<span class="built_in">sqrt</span>(P)),calc(),q=read();q--;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l=read(),d=read(),t_=read(),ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;++i) (ans+=<span class="number">1l</span>l*a[i]*((C(d+i+t_,l+i+<span class="number">1</span>)-C(d+i,l+i+<span class="number">1</span>)+P)%P)%P*fact[i+l]%P)%=P;</span><br><span class="line">ans=<span class="number">1l</span>l*ans*invf[l]%P,write(ans),<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;假定有$T$天，每天有$K$个小时，你要安排每一天的日程。&lt;br&gt;第$i$天有$D+i−1$道菜，第一个小时你必须选择$L$道菜吃，接下来每个小时你可以选择吃一道菜或者选择$A$个活动中的一个参加，不能连续两个小时吃菜（但是一天的最后一个小时和下一天的第一个小时连着吃是可以的）。&lt;br&gt;$K,A$是事先给定的值。有$Q$次询问，每次给出$L,D,T$，问这$T$天每一天安排的方案数&lt;strong&gt;之和&lt;/strong&gt;。&lt;br&gt;答案对$P$（事先给定）取模。&lt;/p&gt;
&lt;p&gt;$2\leq K\leq 10^5,1\leq Q\leq 500,1\leq L\leq D\leq D+T-1\leq10^7,10^8+7\leq P\leq10^9+7,P\in\mathbb P$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="矩阵" scheme="http://yoursite.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="计数类问题" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="组合数" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="FFT/NTT/FWT" scheme="http://yoursite.com/tags/FFT-NTT-FWT/"/>
    
      <category term="CodeChef" scheme="http://yoursite.com/tags/CodeChef/"/>
    
      <category term="多项式" scheme="http://yoursite.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="预处理" scheme="http://yoursite.com/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JOI2017春季合宿 切符の手配(Arranging Tickets)</title>
    <link href="http://yoursite.com/2018/03/07/joisc2017-d/"/>
    <id>http://yoursite.com/2018/03/07/joisc2017-d/</id>
    <published>2018-03-07T12:20:15.000Z</published>
    <updated>2018-04-16T03:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有$n$个车站按照顺时针顺序围成一圈，编号为$1,2,…,n$。<br>有$n$种车票，其中第$i$种车票可以从第$i$个车站前往第$i+1$个车站，也可以从第$i+1$个车站前往第$i$种车站。<br>有$m$类旅客，第$i$类旅客总共有$c_i$人，要从第$a_i$个车站前往第$b_i$个车站（可以走两个方向）。<br>你要给每一个旅客决定出行路线，最小化所有种类的车票需要数目的最大值。</p><p>$3\leq n\leq2\times10^5,1\leq m\leq10^5$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>这是一道非常难的题目，需要发现很多性质，证明一些结论。感谢<a href="http://blog.csdn.net/lych_cys" target="_blank" rel="noopener">lych_cys</a>耐心教做人qwq</p><h2 id="O-mn-2-log-2n-（保证-c-i-1-）"><a href="#O-mn-2-log-2n-（保证-c-i-1-）" class="headerlink" title="$O(mn^2\log^2n)$（保证$c_i=1$）"></a>$O(mn^2\log^2n)$（保证$c_i=1$）</h2><p>首先我们肯定要破环为链，考虑将问题转化成这样：<br>一个数轴上有$n$个整点，$m$种区间。第$i$种区间覆盖了$[a_i,b_i)$的整点，有$c_i$个。<br>你可以选择一些区间翻转，原本覆盖$[l,r)$的现在覆盖$[1,l)\bigcup[r,n]$。<br>请最小化被覆盖的最多的整点被覆盖的次数。<br>显然，答案具有二分性：如果答案$ans$是可行的，那么$ans+1,ans+2,…$直到理论上界都是可行的。因此考虑二分答案并判定。<br>我们可以得到一个观察结论：对于区间$[l,r)$和区间$[x,y)$，如果$l\lt r\leq x\lt y$，即区间没有交，它们不可能同时翻转（画一画就知道不翻转显然会更优）。<br>也就是说所有翻转的区间，一定会有至少一个公共的交点，我们设它为$t$。<br>考虑枚举这个$t$，然后判定答案是否可行。<br>假设我们总共需要翻转$cnt$次，答案为$ans$，这两个都是判定前需要确定的参数。<br>判定过程是这样一个贪心的过程：</p><ul><li>维护一个大根堆。</li><li>For $i=1$ -&gt; $t$<br>– 将所有左端点在$i$的，右端点$r&gt;t$的区间都丢到堆里面，关键字是右端点。<br>– 如果当前已经翻转过的区间个数还没有达到这个位置合法所需要的次数，选择堆顶区间翻转，如果堆为空返回不合法。</li><li>最后检验一次方案是否合法。</li></ul><p>注意到我们是按照左端点从小到大的顺序贪心，因此后面的翻转决策可能会导致前面的位置被覆盖次数增加，所以我们不可以单纯按照当前位置初始覆盖次数和$ans$来决定选取的区间个数。<br>假设前面当前位置现在（即考虑了前面的翻转造成的贡献）被覆盖次数是$y$，后面还有$T$次翻转操作。<br>那么当前翻转次数$x$应当满足$y-x+T-x\lt ans$。我们取合法的$x$的最小值即可。<br>注意到上面我们是假定了后面$T$次翻转操作都是会造成当前位置被覆盖次数增加，但实际上并不一定。<br>不过没有关系，假设后面的实际上造成的当前位置被覆盖次数减少，前面这一次翻转也并不是多余的（不然就不会有后面这一次翻转），而且次数减少的话依然是合法的。<br>这个贪心为什么是对的呢？<br>首先它的答案肯定是合法的，因为我们最后会检测一次。<br>其次，可以发现这个贪心使得$1…t$都合法的同时，最小了$t+1…n$被覆盖的次数（每次都是取右端点最大的区间）。<br>于是我们二分$ans$，枚举交集的一个点$t$和翻转总次数$cnt$。<br>当$c_i=1$的时候我们得到了一个$O(mn^2\log^2n)$的多项式做法。<br>然后可以发现我们有两个复杂度瓶颈：一个是枚举的总翻转次数$cnt$，一个是交集的其中一个位置$t$。<br>我们要将这两个东西优化下来才可以通过这道题目。</p><h2 id="O-n-2-log-2n"><a href="#O-n-2-log-2n" class="headerlink" title="$O(n^2\log^2n)$"></a>$O(n^2\log^2n)$</h2><p>我们先来解决第一个问题，在后面的论证中你可以看到，$cnt$其实只需要取两个值检验就好了。<br>我们假定$a_i$表示的是最初状态下每一个整点被覆盖的次数。<br>$b_i$表示的是翻转了之后每一个整点被覆盖的次数。<br>假设有一种最优方案翻转的区间的交集是$[l,r)$，我们取$b_l,b_{l+1},…,b_{r-1}$里面最大的作为$b_t$。</p><p>定理：一定存在一种最优的翻转方案，使得$b_t=\max b_i$或者$b_t=\max b_i-1$。<br>证明：<br>假定存在一个最优的方案不满足这个上界。$\max b_i$显然不在$[l,r)$。<br>在所有已经翻转的区间中，我们选择右端点最左的和左端点最右的，它们的交集肯定是$[l,r)$。考虑取消翻转这两个区间（也可能是同一个，没有关系）。<br>首先最大值肯定不会增加（增加的只有$[l,r)$），其次所有位置肯定依然合法，最后可以发现$b_t$增加了$1$或者$2$。<br>如果此时还不满足条件，继续做这个过程。最后一定能使得$b_t$达到这个上界。证毕。</p><p>又因为在有解的情况下$\max b_i$一定会等于$ans$。<br>于是我们只需要检验$a_t-ans$或者$a_t-(ans-1)$即可。<br>时间复杂度成功降成了$O(n^2\log^2n)$。而且现在复杂度和$c_i$的取值没有任何关系了！</p><h2 id="O-n-log-2n"><a href="#O-n-log-2n" class="headerlink" title="$O(n\log^2n)$"></a>$O(n\log^2n)$</h2><p>然后我们要优化掉最后一个瓶颈$t$。</p><p>定理：最优解的$t$一定满足$a_t=\max a_i$。</p><p>证明：<br>假设存在最优解，使得$a_t\neq\max a_i$。假设取反的区间交集是$[l,r)$，那么也就是说存在$i\not\in [l,r)$使得$a_i\geq a_t+1$。<br>因为$i$不在$[l,r)$，因此一定有一个区间翻转之后覆盖了$i$。<br>于是肯定有$b_i-a_i\geq b_t-a_t+1$，结合$a_i\geq a_t+1$移项得到$b_t+2\leq b_i$。<br>和前面的事实矛盾！证毕。</p><p>虽然我们确定了$a_t$的取值，但是万一我有好几个$a_t=\max a_i$，那依然要一个一个检测。</p><p>这时候我们需要最后一个定理：$t$只需要取满足$a_t=\max a_i$的最左或者最右的$t$就好了。</p><p>证明：依然是使用反证法。假设$a_l,a_r$是满足条件的最左/最右值，然后假设最优解选择了$a_t(l\lt t\lt r)$。<br>我们只需要证明所有覆盖的区间，要么都覆盖了$a_l$，要么都覆盖了$a_r$。<br>首先因为我们选择了$a_t$，显然没有区间$[x,y)$满足$y\leq l$或者$x&gt;r$。</p><p>引理一：不存在区间$[x,y)$满足$l\lt x\lt y\leq r$。</p><p>证明：<br>假定我们不翻转这个区间，对应的$b$数组是$b’$，于是我们可以得到$b’_t=b_t+1,b’_l=b_l-1$。<br>在不翻转这个区间的时候，显然还是满足$b’_t-a_t\leq b’_l-a_l$，从而有$b’_l\geq b’_t$。<br>然后就有$b_l\geq b_t+2$，和前面的事实矛盾，证毕！</p><p>引理二：假设存在两个区间$[x_1,y_1),[x_2,y_2)$，满足$y_2\leq r$且$x_1&gt;l$。我们同时取消翻转它们，答案不会更劣。</p><p>证明：<br>首先显然有$\max\{b_l,b_{l+1},…,b_r\}=\max(b_i)$。$b’$同理。<br>那么就有$\max b_i=\max_{i\in[1,l]\bigcup[r,n]}\{b_i\}$。$b’$同理。<br>显然同时翻转这两个区间，$\max b_i\geq\max b’_i$。证毕。</p><p>综上，我们二分答案$ans$，然后取$t$为使得$a_t$最大的位置中最左位置和最右位置，取$cnt=a_t-ans$或$a_t-(ans-1)$，用数据结构贪心检验一下就好了。<br>时间复杂度$O(n\log^2n)$。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(a,b) make_pair(a,b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sd second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL INF=LLONG_MAX;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line">LL tag[N],need[N],sum[N];</span><br><span class="line"><span class="keyword">int</span> a[M],b[M],c[M];</span><br><span class="line"><span class="keyword">int</span> n,m,la,ra;</span><br><span class="line">LL mx;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;P&gt; q;</span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL rvs,<span class="keyword">int</span> t,LL lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rvs&gt;lim) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;t;++i) need[i]=max(sum[i]+rvs-lim+<span class="number">1</span>&gt;&gt;<span class="number">1</span>,<span class="number">0l</span>l);</span><br><span class="line">need[t]=rvs;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) range[i].clear(),tag[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;!q.empty();q.pop());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="keyword">if</span> (a[i]&lt;=t&amp;&amp;b[i]&gt;t) range[a[i]].push_back(mkp(b[i],c[i]));</span><br><span class="line">LL cur=<span class="number">0</span>,tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> rg:range[i]) q.push(rg);</span><br><span class="line"><span class="keyword">for</span> (tmp=need[i]-cur;tmp&gt;<span class="number">0</span>&amp;&amp;!q.empty();)</span><br><span class="line">&#123;</span><br><span class="line">P rg=q.top();q.pop();</span><br><span class="line"><span class="keyword">if</span> (tmp&lt;rg.sd) cur+=tmp,rg.sd-=tmp,q.push(rg),tag[t]-=tmp,tag[rg.ft]+=tmp&lt;&lt;<span class="number">1</span>,tag[n]-=tmp,tmp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> cur+=rg.sd,tag[t]-=rg.sd,tag[rg.ft]+=rg.sd&lt;&lt;<span class="number">1</span>,tag[n]-=rg.sd,tmp-=rg.sd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=t+<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span> ((tag[i]+=tag[i<span class="number">-1</span>])+sum[i]&gt;lim) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(LL lim)</span></span>&#123;<span class="keyword">return</span> check(mx-lim,la,lim)||check(mx-lim+<span class="number">1</span>,la,lim)||check(mx-lim,ra,lim)||check(mx-lim+<span class="number">1</span>,ra,lim);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">binary_search</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL l=<span class="number">0</span>,r=mx<span class="number">-1</span>,ret=mx;</span><br><span class="line"><span class="keyword">for</span> (LL mid;l&lt;=r;)</span><br><span class="line">&#123;</span><br><span class="line">mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (judge(mid)) r=(ret=mid)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"tickets.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"tickets.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">n=read(),m=read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=read(),b[i]=read(),c[i]=read();</span><br><span class="line"><span class="keyword">if</span> (a[i]&gt;b[i]) swap(a[i],b[i]);</span><br><span class="line">sum[a[i]]+=c[i],sum[b[i]]-=c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">mx=-INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) mx=max(sum[i],mx);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span> (sum[i]==mx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!la) la=i;</span><br><span class="line">ra=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,binary_search());</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;有$n$个车站按照顺时针顺序围成一圈，编号为$1,2,…,n$。&lt;br&gt;有$n$种车票，其中第$i$种车票可以从第$i$个车站前往第$i+1$个车站，也可以从第$i+1$个车站前往第$i$种车站。&lt;br&gt;有$m$类旅客，第$i$类旅客总共有$c_i$人，要从第$a_i$个车站前往第$b_i$个车站（可以走两个方向）。&lt;br&gt;你要给每一个旅客决定出行路线，最小化所有种类的车票需要数目的最大值。&lt;/p&gt;
&lt;p&gt;$3\leq n\leq2\times10^5,1\leq m\leq10^5$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="二分法" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
      <category term="JOI" scheme="http://yoursite.com/tags/JOI/"/>
    
      <category term="定理题" scheme="http://yoursite.com/tags/%E5%AE%9A%E7%90%86%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2014 TCO Semifinal 2 Division I Hard TwiceTwiceTree</title>
    <link href="http://yoursite.com/2018/03/01/topcoder-tco14-semifinal2-div1-hard/"/>
    <id>http://yoursite.com/2018/03/01/topcoder-tco14-semifinal2-div1-hard/</id>
    <published>2018-03-01T14:41:04.000Z</published>
    <updated>2018-05-24T14:05:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>开始时你有一棵只有$1$个节点的无根树。<br>每次操作对树上每个节点$x$都新建一个节点$y$，并将$y$与$x$连边。每条边的长度为$1$。<br>$n$次操作过后，树中有$2^n$个节点。求其中长度为$D$的简单路径数量。<br>答案对$P$取模。</p><p>$1\leq n\leq10^9,1\leq D\leq500,503\leq P\leq10^9+9,P\in\mathbb{P}$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>首先可以发现每次操作过后，树都是关于一条中心边对称的，考虑利用这一条边将节点数减半dp。<br>令$f_{n,i}$表示$2^n$个节点的树，长度为$i$的简单路径数量，令$g_{n,i}$表示起点为中心边某一个端点的长度为$i$的简单路径的数量。<br>那么显然有$$g_{n,i}=g_{n-1,i}+g_{n-1,i-1}$$$$f_{n,i}=2f_{n-1,i}+\sum_{j=0}^{i-1}g_{n-1,j}g_{n-1,i-1-j}$$考虑写成生成函数的形式：$$g_n(x)=(1+x)^n$$$$f_n(x)=x(1+x)^{2(n-1)}+2f_{n-1}(x)$$使用数列方法解出$f_n(x)$：$$<br>\begin{align}<br>f_n(x)&amp;=x(1+x)^{2(n-1)}+2f_{n-1}(x)\tag{1}\<br>\left[\frac{x^2+2x-1}x f_n(x)-(1+x)^{2n}\right]&amp;=2\left[\frac{x^2+2x-1}x f_{n-1}(x)-(1+x)^{2(n-1)}\right]\tag{2}\<br>f_n(x)&amp;=\frac{x2^n-x(1+x)^{2n}}{1-2x-x^2}+2^n\tag{3}<br>\end{align}$$因为数据范围很小，$O(D^2)$求组合数、求逆和卷积就够了。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXD=<span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%P) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) ret=<span class="number">1l</span>l*ret*x%P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXD],g[MAXD],ans[MAXD];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) ret=<span class="number">1l</span>l*ret*i%P;</span><br><span class="line">ret=quick_power(ret,P<span class="number">-2</span>,P);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n-m+<span class="number">1</span>;i&lt;=n;++i) ret=<span class="number">1l</span>l*ret*i%P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwiceTwiceTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumup</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> D,<span class="keyword">int</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>,f[<span class="number">1</span>]=P<span class="number">-2</span>,f[<span class="number">2</span>]=P<span class="number">-1</span>,g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,sum;i&lt;=D;++i)</span><br><span class="line">&#123;</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j) (sum+=<span class="number">1l</span>l*f[j]*g[i-j]%P)%=P;</span><br><span class="line">g[i]=P-sum;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=D;++i) f[i]=P-C(n&lt;&lt;<span class="number">1</span>,i<span class="number">-1</span>,P);</span><br><span class="line"><span class="keyword">int</span> pw=quick_power(<span class="number">2</span>,n,P);</span><br><span class="line">(f[<span class="number">1</span>]+=pw)%=P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,sum;i&lt;=D;++i)</span><br><span class="line">&#123;</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j) (sum+=<span class="number">1l</span>l*f[j]*g[i-j]%P)%=P;</span><br><span class="line">ans[i]=sum;</span><br><span class="line">&#125;</span><br><span class="line">(ans[<span class="number">0</span>]+=pw)%=P;</span><br><span class="line"><span class="keyword">return</span> ans[D];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;开始时你有一棵只有$1$个节点的无根树。&lt;br&gt;每次操作对树上每个节点$x$都新建一个节点$y$，并将$y$与$x$连边。每条边的长度为$1$。&lt;br&gt;$n$次操作过后，树中有$2^n$个节点。求其中长度为$D$的简单路径数量。&lt;br&gt;答案对$P$取模。&lt;/p&gt;
&lt;p&gt;$1\leq n\leq10^9,1\leq D\leq500,503\leq P\leq10^9+9,P\in\mathbb{P}$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="计数类问题" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="普通动态规划" scheme="http://yoursite.com/tags/%E6%99%AE%E9%80%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="组合数" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="多项式" scheme="http://yoursite.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="生成函数" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="TopCoder" scheme="http://yoursite.com/tags/TopCoder/"/>
    
  </entry>
  
  <entry>
    <title>UOJ310 黎明前的巧克力</title>
    <link href="http://yoursite.com/2018/03/01/uoj310/"/>
    <id>http://yoursite.com/2018/03/01/uoj310/</id>
    <published>2018-03-01T08:14:19.000Z</published>
    <updated>2018-03-02T12:26:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定$n$个数$\{a_n\}$，现在要求从中选出两个不相交的集合，使得这两个集合的各自的异或和相等。<br>可以存在有的数未被选择，集合可以为空，但是两个集合不可以同时为空。<br>求选出这样的集合的方案数。</p><p>$1\leq n\leq10^6,0\leq a_i\leq 10^6$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>首先可以写出一个简单的dp：令$f_{i,s}$表示做到第$i$个数，当前两个集合异或和为$s$的方案数，转移很简单，最后答案就是$f_{n,0}-1$。<br>这个dp是$O(n\max\{a_i\})$的，考虑优化。可以发现这个dp的生成函数其实就是$\prod_{i=1}^n\left(1+2x^{a_i}\right)$，这里的多项式乘法是在异或卷积意义下的。<br>如果我们直接对这$n$个生成函数做DWT乘起来最后再DWT回去会比直接dp还要慢，考虑观察DWT的值的性质：<br>在异或DWT中，我们有转移$(f_0+f_1,f_0-f_1)$，因此一个值$x$会给最后的序列每一个位置贡献$x$或者$-x$，这取决于中途它从$f_1$转移到$f_1$的次数的奇偶性。于是这里的双项式DWT之后一个位置只可能有$-1$或者$3$两种可能（常数项贡献肯定是$1$）。<br>考虑使用dp来计算两种取值的个数，令$f_{i,0/1}$表示第$i$个位置经历$0/1$奇偶性次的符号取反。转移很简单，右半边转移到右半边的时候$0/1$反一反就好了。<br>利用dp数组我们就可以计算出每一位DWT之后的值（$(-1)^{f_1}3^{f_0}$），直接IDWT一次固然是可以。但是注意到我们只需要计算出常数项的值，那么我们只需要把所有数加起来除以次数界就好了。<br>时间复杂度$O(\max\{a_i\}\log \max\{a_i\})$。不把那个dp当做FWT的话，这道题用FWT推，到最后连FWT都不需要写（雾）？<br>fake得不行。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f=ch==<span class="string">'-'</span>?<span class="number">-1</span>:f,ch=getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1048576</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quick_power</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%P) <span class="keyword">if</span> (y&amp;<span class="number">1</span>) ret=<span class="number">1l</span>l*ret*x%P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> g[N];</span><br><span class="line"><span class="keyword">int</span> n,len,mx,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">trs</span><span class="params">(<span class="keyword">int</span> *l,<span class="keyword">int</span> *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> l_[<span class="number">2</span>],r_[<span class="number">2</span>];</span><br><span class="line">l_[<span class="number">0</span>]=l[<span class="number">0</span>],l_[<span class="number">1</span>]=l[<span class="number">1</span>],r_[<span class="number">0</span>]=r[<span class="number">0</span>],r_[<span class="number">1</span>]=r[<span class="number">1</span>];</span><br><span class="line">l[<span class="number">0</span>]=(l_[<span class="number">0</span>]+r_[<span class="number">0</span>])%P,l[<span class="number">1</span>]=(l_[<span class="number">1</span>]+r_[<span class="number">1</span>])%P;</span><br><span class="line">r[<span class="number">0</span>]=(l_[<span class="number">0</span>]+r_[<span class="number">1</span>])%P,r[<span class="number">1</span>]=(l_[<span class="number">1</span>]+r_[<span class="number">0</span>])%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DWT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">2</span>;l&lt;=len;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,h=l&gt;&gt;<span class="number">1</span>;j&lt;len;j+=l)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;++i)</span><br><span class="line">trs(f[i+j],f[i+j+h]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"chocolate.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"chocolate.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">n=read(),mx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) ++f[x=read()][<span class="number">0</span>],mx=max(mx,x);</span><br><span class="line"><span class="keyword">for</span> (len=<span class="number">1</span>;len&lt;=mx;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">DWT();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) g[i]=<span class="number">1l</span>l*quick_power(<span class="number">3</span>,f[i][<span class="number">0</span>])*quick_power(P<span class="number">-1</span>,f[i][<span class="number">1</span>])%P;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) (ans+=g[i])%=P;</span><br><span class="line">ans=(<span class="number">1l</span>l*ans*quick_power(len,P<span class="number">-2</span>)%P+P<span class="number">-1</span>)%P;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定$n$个数$\{a_n\}$，现在要求从中选出两个不相交的集合，使得这两个集合的各自的异或和相等。&lt;br&gt;可以存在有的数未被选择，集合可以为空，但是两个集合不可以同时为空。&lt;br&gt;求选出这样的集合的方案数。&lt;/p&gt;
&lt;p&gt;$1\leq n\leq10^6,0\leq a_i\leq 10^6$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="计数类问题" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="普通动态规划" scheme="http://yoursite.com/tags/%E6%99%AE%E9%80%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="FFT/NTT/FWT" scheme="http://yoursite.com/tags/FFT-NTT-FWT/"/>
    
      <category term="多项式" scheme="http://yoursite.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="生成函数" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="UOJ" scheme="http://yoursite.com/tags/UOJ/"/>
    
  </entry>
  
  <entry>
    <title>hihoCoder Challenge 21 C - Reachable Permutations</title>
    <link href="http://yoursite.com/2018/03/01/hihocoder-challenge21-c/"/>
    <id>http://yoursite.com/2018/03/01/hihocoder-challenge21-c/</id>
    <published>2018-03-01T06:30:54.000Z</published>
    <updated>2018-03-28T08:13:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个排列$\{a_n\}$。<br>你要对这个排列进行任意次变换，每次你可以选择排列中的一个逆序对进行交换。<br>请求出所有可以通过上面的变换得到的排列的总数。答案对$10^9+7$取模。</p><p>$1\leq n\leq20$<br><a id="more"></a></p><hr><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>考虑最终排列合法的条件是什么。<br>不妨先考虑对一个$0/1$序列执行变换操作，那么序列$\{b_n\}$合法当且仅当其中的$1$和$\{a_n\}$中的相等，并且$\{b_n\}$第$i$个$1$的位置一定在$\{a_n\}$第$i$个$1$的右方（可以不严格）。<br>现在来考虑排列的合法条件，很显然可以想到枚举一个数$k$，然后改写排列：大于$k$的都是$1$，小于等于的都是$0$。直接套用$0/1$序列的结论得到：合法当且仅当所有$1…n$的$k$写出的$0/1$序列都合法。<br>这个结论的必要性显然。充分性可以通过下面这个归纳的求解过程来证明：考虑以$n…1$的顺序将所有的数都换到对应的位置上，每次假设$i$在$l$位置，需要换到$r$上，显然在做$n$的时候$l\leq r$显然成立，如果后面的过程这个还满足就可以成功交换了。令当前$(l,r]$区间的最大未匹配数字是$a_j$，那么交换$a_l$和$a_j$，不断重复直到$l=r$。可以发现，这个操作相当于将$k=i-1…1$的$0/1$序列$(l,r]$区间上的最后一个$1$和目标的$r$匹配，这样子剩下来的$0/1$序列肯定依然满足条件。因此到最后在做$i$的时候，$k=i-1$的$0/1$序列一定只剩下一个$1$，因为这是一个合法的$0/1$序列，因此这个$1$一定在目标位置的前面，证毕。<br>那么接下来就很简单了，模拟$k=1…n$的过程，相当于我们一开始有一个全部都是$0$的$0/1$序列，然后每一次我们要将一个$0$变成$1$，新的$0/1$序列还要满足关于$k$那个$0/1$序列合法。<br>简单的状压就可以做到$O(n2^n)$。</p><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=<span class="number">1</span>&lt;&lt;N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[S],bits[S];</span><br><span class="line"><span class="keyword">int</span> state[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line">ret+=((x&gt;&gt;i)&amp;<span class="number">1</span>)-((y&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"rpers.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"rpers.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,x;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),state[n-x+<span class="number">1</span>]=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) state[i]|=state[i<span class="number">-1</span>];</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;<span class="number">1</span>&lt;&lt;n;++s)</span><br><span class="line">&#123;</span><br><span class="line">bits[s]=bits[s&gt;&gt;<span class="number">1</span>]+(s&amp;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!s||judge(state[bits[s]],s)) <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">if</span> (!((s&gt;&gt;i)&amp;<span class="number">1</span>)) (f[s|(<span class="number">1</span>&lt;&lt;i)]+=f[s])%=P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]);</span><br><span class="line">fclose(<span class="built_in">stdin</span>),fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h1&gt;&lt;p&gt;给定一个排列$\{a_n\}$。&lt;br&gt;你要对这个排列进行任意次变换，每次你可以选择排列中的一个逆序对进行交换。&lt;br&gt;请求出所有可以通过上面的变换得到的排列的总数。答案对$10^9+7$取模。&lt;/p&gt;
&lt;p&gt;$1\leq n\leq20$&lt;br&gt;
    
    </summary>
    
      <category term="解题报告" scheme="http://yoursite.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="bitmasks" scheme="http://yoursite.com/tags/bitmasks/"/>
    
      <category term="计数类问题" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="状压动态规划" scheme="http://yoursite.com/tags/%E7%8A%B6%E5%8E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="归纳" scheme="http://yoursite.com/tags/%E5%BD%92%E7%BA%B3/"/>
    
      <category term="hihoCoder" scheme="http://yoursite.com/tags/hihoCoder/"/>
    
      <category term="逆序对" scheme="http://yoursite.com/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
  </entry>
  
</feed>
